<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#e51636">
    <!-- Social sharing meta tags for Snapchat/iMessage/etc -->
    <meta property="og:title" content="MURRY FUEL - A Chick-fil-A Addiction Story">
    <meta property="og:description" content="Help Murry eat Chick-fil-A without having an accident! A hilarious mobile game.">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="MURRY FUEL">
    <meta name="twitter:description" content="Help Murry eat Chick-fil-A without pooping himself!">
    <title>MURRY FUEL - A Chick-fil-A Addiction Story</title>
    <!-- Prevent phone number detection -->
    <meta name="format-detection" content="telephone=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }
        #gameContainer {
            text-align: center;
            position: relative;
            width: 100%;
            max-width: 850px;
            padding: 5px;
        }
        h1 {
            color: #e51636;
            font-size: clamp(1.2em, 5vw, 2.2em);
            margin-bottom: 3px;
            text-shadow: 2px 2px 0px #ffffff;
        }
        .subtitle {
            color: #ffffff;
            font-size: clamp(0.65em, 2.5vw, 0.85em);
            margin-bottom: 5px;
            font-style: italic;
        }
        #hud {
            display: flex;
            justify-content: space-around;
            padding: 8px 12px;
            background: linear-gradient(180deg, #e51636 0%, #c41230 100%);
            border-radius: 8px;
            margin-bottom: 5px;
            flex-wrap: wrap;
            gap: 8px;
            border: 2px solid #ffffff;
        }
        .hud-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .hud-label {
            color: #ffffff;
            font-size: clamp(0.65em, 2vw, 0.8em);
            font-weight: bold;
        }
        .hud-value {
            color: #ffffff;
            font-size: clamp(0.9em, 2.5vw, 1.1em);
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .meter-container {
            width: clamp(70px, 18vw, 110px);
            height: 16px;
            background: #8b0000;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #ffffff;
        }
        #hungerMeter {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d);
            width: 100%;
            transition: width 0.3s;
        }
        #bellyMeter {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #fbbf24, #ef4444);
            width: 0%;
            transition: width 0.3s;
        }
        #canvasWrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }
        canvas {
            border: 4px solid #e51636;
            border-radius: 10px;
            box-shadow: 0 0 25px rgba(229, 22, 54, 0.4);
            display: block;
            width: 100%;
            height: auto;
            touch-action: none;
        }
        #instructions {
            color: #aaa;
            margin-top: 8px;
            font-size: clamp(0.6em, 2vw, 0.85em);
            padding: 0 10px;
        }
        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #e51636 0%, #a01128 100%);
            padding: clamp(20px, 4vw, 40px);
            border-radius: 20px;
            border: 4px solid #ffffff;
            z-index: 100;
            width: 90%;
            max-width: 420px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #overlay h2 {
            color: #ffffff;
            font-size: clamp(1.4em, 5vw, 2em);
            margin-bottom: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        #overlay p {
            color: #ffffff;
            font-size: clamp(0.9em, 3vw, 1.1em);
            margin-bottom: 10px;
        }
        #overlay .info {
            color: rgba(255,255,255,0.9);
            font-size: clamp(0.75em, 2.5vw, 0.9em);
            margin: 12px 0;
            line-height: 1.5;
        }
        #overlay .highscore {
            color: #ffd93d;
            font-size: clamp(1em, 3vw, 1.2em);
            font-weight: bold;
            margin: 10px 0;
        }
        #overlay button {
            background: #ffffff;
            color: #e51636;
            border: none;
            padding: clamp(12px, 3vw, 18px) clamp(30px, 8vw, 50px);
            font-size: clamp(1.1em, 3.5vw, 1.3em);
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            margin-top: 10px;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        #overlay button:hover, #overlay button:active {
            transform: scale(1.05);
        }
        .hidden { display: none !important; }

        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            z-index: 50;
            background: linear-gradient(to top, rgba(0,0,0,0.3) 0%, transparent 100%);
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 500px;
            margin: 0 auto;
            padding: 0 10px;
        }
        .dpad {
            display: flex;
            gap: 12px;
        }
        .dpad-btn {
            width: 70px;
            height: 70px;
            background: rgba(229, 22, 54, 0.85);
            border: 3px solid #ffffff;
            border-radius: 15px;
            color: white;
            font-size: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: transform 0.08s, background 0.08s;
        }
        .dpad-btn:active, .dpad-btn.active {
            background: #e51636;
            transform: scale(0.92);
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        #jumpBtn {
            width: 90px;
            height: 90px;
            background: rgba(229, 22, 54, 0.85);
            border: 3px solid #ffffff;
            border-radius: 50%;
            color: white;
            font-size: 15px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            box-shadow: 0 4px 15px rgba(0,0,0,0.35);
            transition: transform 0.08s, background 0.08s;
        }
        #jumpBtn:active, #jumpBtn.active {
            background: #e51636;
            transform: scale(0.92);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        /* Mobile detection and layout */
        @media (hover: none) and (pointer: coarse) {
            #mobileControls { display: block; }
            #instructions { display: none; }
            #gameContainer {
                padding-bottom: calc(130px + env(safe-area-inset-bottom, 0px));
            }
            body {
                padding-top: env(safe-area-inset-top, 0px);
            }
        }

        /* Small phones */
        @media (max-width: 380px) {
            .dpad-btn { width: 55px; height: 55px; font-size: 22px; }
            #jumpBtn { width: 70px; height: 70px; font-size: 13px; }
            .dpad { gap: 8px; }
        }

        /* Landscape mode */
        @media (max-height: 500px) and (orientation: landscape) {
            h1 { font-size: 1.1em; margin-bottom: 2px; }
            .subtitle { display: none; }
            #hud { padding: 4px 8px; gap: 4px; }
            .meter-container { width: 55px; height: 12px; }
            #mobileControls {
                padding: 5px;
                padding-bottom: calc(5px + env(safe-area-inset-bottom, 0px));
            }
            .dpad-btn { width: 50px; height: 50px; font-size: 20px; }
            #jumpBtn { width: 70px; height: 70px; font-size: 12px; }
            #gameContainer {
                padding-bottom: calc(90px + env(safe-area-inset-bottom, 0px));
            }
        }

        /* Prevent text selection and callouts */
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>üêî MURRY FUEL üêî</h1>
        <div class="subtitle">"My pleasure... to eat ALL of it"</div>
        <div id="hud">
            <div class="hud-item">
                <span class="hud-label">SCORE</span>
                <span class="hud-value" id="scoreDisplay">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">üçó HUNGER</span>
                <div class="meter-container"><div id="hungerMeter"></div></div>
            </div>
            <div class="hud-item">
                <span class="hud-label">üíÄ BELLY</span>
                <div class="meter-container"><div id="bellyMeter"></div></div>
            </div>
            <div class="hud-item">
                <span class="hud-label">üèÜ BEST</span>
                <span class="hud-value" id="highScoreDisplay">0</span>
            </div>
        </div>
        <div id="canvasWrapper">
            <canvas id="game" width="800" height="500"></canvas>
        </div>
        <div id="instructions">‚¨ÖÔ∏è‚û°Ô∏è Move | SPACE Jump | Eat Chick-fil-A ‚Üí Don't poop yourself!</div>

        <div id="overlay">
            <h2 id="overlayTitle">üêî MURRY FUEL üêî</h2>
            <p id="overlayText">A Chick-fil-A Addiction Story</p>
            <div class="info" id="overlayInfo">Murry can't stop eating Chick-fil-A...<br>Help him eat as much as possible without having an "accident"!</div>
            <div class="highscore" id="overlayHighscore"></div>
            <button id="overlayBtn">EAT MY PLEASURE</button>
        </div>
    </div>

    <div id="mobileControls">
        <div class="control-row">
            <div class="dpad">
                <div class="dpad-btn" id="leftBtn">‚¨ÖÔ∏è</div>
                <div class="dpad-btn" id="rightBtn">‚û°Ô∏è</div>
            </div>
            <div id="jumpBtn">JUMP</div>
        </div>
    </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const overlayInfo = document.getElementById('overlayInfo');
const overlayHighscore = document.getElementById('overlayHighscore');
const overlayBtn = document.getElementById('overlayBtn');

// ============== AUDIO ==============
let audioCtx = null;
function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type) {
    if (!audioCtx) return;
    try {
        switch(type) {
            case 'eat': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(250, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.08);
                gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.1);
                break;
            }
            case 'burp': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(90, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.35, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.45);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.45);
                break;
            }
            case 'fart': {
                const bufferSize = audioCtx.sampleRate * 0.4;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.12));
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(180, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.35);
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);
                break;
            }
            case 'bigfart': {
                const bufferSize = audioCtx.sampleRate * 1.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const env = Math.exp(-i / (bufferSize * 0.35));
                    const wobble = Math.sin(i / 400) * 0.5 + 0.5;
                    data[i] = (Math.random() * 2 - 1) * env * wobble;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(280, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 1.2);
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.6, audioCtx.currentTime);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);
                break;
            }
            case 'flush': {
                const bufferSize = audioCtx.sampleRate * 2.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const progress = i / bufferSize;
                    const env = Math.sin(progress * Math.PI);
                    data[i] = (Math.random() * 2 - 1) * env;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(800, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 2);
                filter.Q.value = 1;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);
                break;
            }
            case 'relief': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(380, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(280, audioCtx.currentTime + 0.4);
                osc.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 1);
                gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.1);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 1.1);
                break;
            }
            case 'accident': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(280, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.6);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.6);

                setTimeout(() => {
                    const bufferSize = audioCtx.sampleRate * 0.4;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.08));
                    }
                    const noise = audioCtx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 350;
                    const g = audioCtx.createGain();
                    g.gain.value = 0.45;
                    noise.connect(filter);
                    filter.connect(g);
                    g.connect(audioCtx.destination);
                    noise.start();
                }, 250);
                break;
            }
            case 'jump': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(180, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(350, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.12);
                break;
            }
            case 'rumble': {
                // Stomach rumble sound
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(45, audioCtx.currentTime);
                osc.frequency.setValueAtTime(60, audioCtx.currentTime + 0.2);
                osc.frequency.setValueAtTime(35, audioCtx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.5);
                break;
            }
            case 'rage': {
                // Angry rage sound - aggressive distorted tone
                const osc = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const distortion = audioCtx.createWaveShaper();

                // Create distortion curve
                const curve = new Float32Array(256);
                for (let i = 0; i < 256; i++) {
                    const x = (i - 128) / 128;
                    curve[i] = Math.tanh(x * 3);
                }
                distortion.curve = curve;

                osc.connect(distortion);
                osc2.connect(distortion);
                distortion.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.3);
                osc2.frequency.setValueAtTime(155, audioCtx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(85, audioCtx.currentTime + 0.3);

                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);

                osc.start(audioCtx.currentTime);
                osc2.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.35);
                osc2.stop(audioCtx.currentTime + 0.35);
                break;
            }
            case 'break': {
                // Putter breaking sound - snap/crack
                const bufferSize = audioCtx.sampleRate * 0.15;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.03));
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 800;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);
                break;
            }
            case 'gameover': {
                const notes = [400, 350, 300, 200];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime + i * 0.2);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.2 + 0.25);
                    osc.start(audioCtx.currentTime + i * 0.2);
                    osc.stop(audioCtx.currentTime + i * 0.2 + 0.25);
                });
                break;
            }
        }
    } catch(e) {}
}

// ============== GAME STATE ==============
let gameState = 'menu';
let score = 0;
let highScore = parseInt(localStorage.getItem('murryFuelHighScore')) || 0;
let gameTime = 0;
let difficulty = 1; // Increases over time
let screenShake = { x: 0, y: 0, intensity: 0 };
let floatingTexts = [];
let stinkClouds = [];

// Murry's lifetime stats (for this run)
let totalItemsEaten = 0;
let totalPoops = 0;

// Quotes
const quotes = {
    eat: ["MY PLEASURE!", "DELICIOUS!", "OH YEAH!", "NOM NOM!", "CRISPY!", "WORTH IT!", "SO GOOD!", "MORE!", "YUMMY!", "CHICK-FIL-AAAA!", "CLOSED SUNDAYS!", "EAT MOR CHIKIN!", "LIFE GOALS!", "I LOVE CFA!"],
    eatSpicy: ["SPICY!!", "üî•üî•üî•", "HOT HOT HOT!", "MY MOUTH!", "WORTH IT!", "SPICY DELUXE!", "FEELS GOOD!", "REGRET INCOMING!", "MY BOOTY LATER..."],
    eatFries: ["WAFFLE FRIES!", "CRISPY!", "SALTY!", "PERFECT!", "MMM FRIES!", "PERFECTION!", "NEED SAUCE!"],
    full: ["OH NO...", "UH OH!", "GOTTA GO!", "PRAIRIE DOGGING!", "CODE BROWN!", "EMERGENCY!", "CLENCH!!", "HOLD IT IN!", "NOT HERE!", "BATHROOM NOW!", "ITS COMING!", "TURTLE HEAD!", "DANGER ZONE!"],
    relief: ["AHHHHH!", "SWEET RELIEF!", "MUCH BETTER!", "GLORIOUS!", "FINALLY!", "YEEEESSS!", "THANK GOD!", "THAT WAS CLOSE!", "ROOM FOR MORE!", "BACK IN BUSINESS!"],
    accident: ["OOPS!", "NOT AGAIN!", "MY KHAKIS!", "SHAME...", "OH NO!", "WHOOPSIE!", "I REGRET NOTHING!", "WORTH IT THO...", "STILL WORTH IT!", "MY SHORTS!!!"],
    hungry: ["NEED... CFA...", "SO HUNGRY!", "FEED ME!", "STARVING!", "CHICK-FIL-A PLEASE!", "WHERE'S THE CFA?!", "NEED CHICKEN!", "WITHDRAWALS!"]
};

function getRandomQuote(type) {
    const arr = quotes[type];
    return arr[Math.floor(Math.random() * arr.length)];
}

// Murry
const murry = {
    x: 380, y: 350,
    width: 50, height: 70,
    vx: 0, vy: 0,
    speed: 5.5,
    jumpPower: -14,
    onGround: false,
    facing: 1,
    belly: 0,
    hunger: 100,
    state: 'idle',
    animFrame: 0,
    poopTimer: 0,
    accidentTimer: 0,
    danceTimer: 0,
    sweatDrops: [],
    eyeSize: 1,
    faceRedness: 0,
    // Murry gets FATTER over the game
    fatness: 0, // 0-100, increases with total food eaten
    blinkTimer: 100,
    isBlinking: false,
    mouthOpen: 0,
    // RAGE MODE
    rageTimer: 0,
    isRaging: false,
    puttersBroken: 0
};

const GRAVITY = 0.55;
const FRICTION = 0.85;
const ACCIDENT_TIME = 240; // 4 seconds

// World
let platforms = [];
let toilet = {};
let foodItems = []; // sandwiches, spicy sandwiches, waffle fries
let putters = []; // Golf putters that trigger RAGE MODE

const keys = {};

// Rage quotes
const rageQuotes = [
    "MURRY RAGE!!!",
    "BREAK IT!!!",
    "STUPID PUTTER!",
    "GOLF SUCKS!",
    "AAAARRRGH!",
    "I HATE GOLF!",
    "HULK MURRY!",
    "RAGE MODE!",
    "DESTROYED!",
    "NO MORE GOLF!"
];

// ============== EFFECTS ==============
function addFloatingText(x, y, text, color = '#fff', size = 16) {
    floatingTexts.push({ x, y, text, color, size, vy: -2.5, life: 1, decay: 0.018 });
}

function addStinkCloud(x, y, big = false) {
    const count = big ? 6 : 3;
    for (let i = 0; i < count; i++) {
        stinkClouds.push({
            x: x + (Math.random() - 0.5) * 25,
            y: y + (Math.random() - 0.5) * 12,
            size: big ? 18 + Math.random() * 22 : 10 + Math.random() * 14,
            vx: (Math.random() - 0.5) * 2.5,
            vy: -0.6 - Math.random() * 1.2,
            life: 1,
            decay: 0.007,
            rotation: Math.random() * Math.PI * 2
        });
    }
}

function createParticles(x, y, colors, count, options = {}) {
    for (let i = 0; i < count; i++) {
        floatingTexts.push({
            x: x + (Math.random() - 0.5) * (options.spread || 10),
            y: y + (Math.random() - 0.5) * (options.spread || 10),
            text: '',
            color: Array.isArray(colors) ? colors[Math.floor(Math.random() * colors.length)] : colors,
            size: (options.size || 4) + Math.random() * 4,
            vy: (options.vy || -3) + (Math.random() - 0.5) * 3,
            vx: (Math.random() - 0.5) * (options.spreadX || 4),
            life: 1,
            decay: 0.025,
            isParticle: true
        });
    }
}

// ============== GAME SETUP ==============
function startGame() {
    score = 0;
    gameTime = 0;
    difficulty = 1;
    totalItemsEaten = 0;
    totalPoops = 0;

    murry.x = 380;
    murry.y = 350;
    murry.vx = 0;
    murry.vy = 0;
    murry.belly = 0;
    murry.hunger = 100;
    murry.state = 'idle';
    murry.fatness = 0;
    murry.accidentTimer = 0;
    murry.faceRedness = 0;
    murry.eyeSize = 1;
    murry.sweatDrops = [];
    murry.rageTimer = 0;
    murry.isRaging = false;
    murry.puttersBroken = 0;

    floatingTexts = [];
    stinkClouds = [];
    putters = [];

    // Setup platforms
    platforms = [
        { x: 0, y: 460, w: 800, h: 40, type: 'grass' },
        { x: 80, y: 370, w: 130, h: 18, type: 'wood' },
        { x: 320, y: 320, w: 160, h: 18, type: 'wood' },
        { x: 580, y: 370, w: 130, h: 18, type: 'wood' },
        { x: 180, y: 240, w: 120, h: 18, type: 'wood' },
        { x: 480, y: 220, w: 120, h: 18, type: 'wood' },
    ];

    toilet = { x: 700, y: 392, w: 60, h: 68 };

    spawnFood();
    updateHUD();
}

function spawnFood() {
    foodItems = [];
    const validPlatforms = platforms.filter(p => p.w >= 100);

    // Number of items scales with difficulty
    const itemCount = Math.min(4 + Math.floor(difficulty / 2), 8);

    for (let i = 0; i < itemCount; i++) {
        const plat = validPlatforms[Math.floor(Math.random() * validPlatforms.length)];
        const rand = Math.random();
        let type;
        if (rand < 0.5) type = 'sandwich';
        else if (rand < 0.75) type = 'spicy';
        else type = 'fries';

        foodItems.push({
            x: plat.x + 15 + Math.random() * (plat.w - 50),
            y: plat.y - 32,
            w: type === 'fries' ? 30 : 40,
            h: type === 'fries' ? 35 : 32,
            type: type,
            collected: false,
            bob: Math.random() * Math.PI * 2
        });
    }

    // Spawn a putter randomly (30% chance per food spawn cycle)
    if (Math.random() < 0.3 && putters.length < 2) {
        spawnPutter();
    }
}

function spawnPutter() {
    // Spawn putter floating in a random location
    const x = 100 + Math.random() * 600;
    const y = 150 + Math.random() * 200;

    putters.push({
        x: x,
        y: y,
        w: 50,
        h: 20,
        bob: Math.random() * Math.PI * 2,
        rotation: Math.random() * 0.3 - 0.15,
        broken: false
    });
}

// ============== INPUT ==============
document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) e.preventDefault();
    initAudio();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

function setupMobileControls() {
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    function addTouchEvents(element, keyCode) {
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys[keyCode] = true;
            element.classList.add('active');
            initAudio();
        }, { passive: false });
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[keyCode] = false;
            element.classList.remove('active');
        }, { passive: false });
        element.addEventListener('touchcancel', () => {
            keys[keyCode] = false;
            element.classList.remove('active');
        });
    }

    addTouchEvents(leftBtn, 'ArrowLeft');
    addTouchEvents(rightBtn, 'ArrowRight');
    addTouchEvents(jumpBtn, 'Space');
}

document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

overlayBtn.addEventListener('click', handleOverlayClick);
overlayBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleOverlayClick(); });

function handleOverlayClick() {
    initAudio();
    if (gameState === 'menu' || gameState === 'gameover') {
        startGame();
        gameState = 'playing';
        hideOverlay();
    }
}

function showOverlay(title, text, info, btn, showHS = true) {
    overlayTitle.textContent = title;
    overlayText.textContent = text;
    overlayInfo.innerHTML = info;
    overlayBtn.textContent = btn;
    if (showHS && highScore > 0) {
        overlayHighscore.textContent = `üèÜ HIGH SCORE: ${highScore}`;
        overlayHighscore.style.display = 'block';
    } else {
        overlayHighscore.style.display = 'none';
    }
    overlay.classList.remove('hidden');
}

function hideOverlay() {
    overlay.classList.add('hidden');
}

function updateHUD() {
    document.getElementById('scoreDisplay').textContent = score;
    document.getElementById('highScoreDisplay').textContent = highScore;
    document.getElementById('hungerMeter').style.width = Math.max(0, murry.hunger) + '%';
    document.getElementById('bellyMeter').style.width = Math.min(100, murry.belly) + '%';
}

// ============== UPDATE ==============
function update() {
    if (gameState !== 'playing') return;

    gameTime++;
    murry.animFrame++;

    // Increase difficulty over time
    difficulty = 1 + Math.floor(gameTime / 600) * 0.5; // Every 10 seconds

    // Blinking
    murry.blinkTimer--;
    if (murry.blinkTimer <= 0) {
        murry.isBlinking = !murry.isBlinking;
        murry.blinkTimer = murry.isBlinking ? 6 : 100 + Math.random() * 150;
    }

    // Hunger decay (faster over time)
    const hungerDecay = 0.035 + difficulty * 0.008;
    murry.hunger -= hungerDecay;

    if (murry.hunger <= 0) {
        murry.hunger = 0;
        gameOver('starved');
        return;
    }

    // Hungry warning
    if (murry.hunger < 25 && gameTime % 90 === 0) {
        addFloatingText(murry.x + 25, murry.y - 40, getRandomQuote('hungry'), '#ff6b6b', 14);
    }

    // Victory dance after poop
    if (murry.state === 'dancing') {
        murry.danceTimer--;
        if (murry.danceTimer <= 0) {
            murry.state = 'idle';
        }
        updateEffects();
        updateHUD();
        return;
    }

    // Pooping - THE MAIN EVENT
    if (murry.state === 'pooping') {
        murry.poopTimer++;

        // Constant rumbling shake during the deed
        screenShake.intensity = Math.max(screenShake.intensity, 3 + Math.sin(murry.poopTimer * 0.3) * 2);

        // Stink clouds throughout
        if (murry.poopTimer % 8 === 0) {
            addStinkCloud(murry.x + 25, murry.y + 55, true);
            if (Math.random() < 0.4) playSound('fart');
        }

        // Buildup phase - increasing intensity
        if (murry.poopTimer === 20) {
            addFloatingText(murry.x + 25, murry.y - 40, "HERE IT COMES...", '#fbbf24', 16);
            screenShake.intensity = 8;
        }
        if (murry.poopTimer === 45) {
            addFloatingText(murry.x + 25, murry.y - 50, "HNNNGGGG!", '#ef4444', 20);
            screenShake.intensity = 15;
            playSound('bigfart');
        }

        // THE BIG FINISH
        if (murry.poopTimer > 75) {
            murry.belly = 0;
            murry.state = 'dancing';
            murry.danceTimer = 60;
            murry.accidentTimer = 0;
            murry.faceRedness = 0;
            totalPoops++;
            score += 50;

            // MASSIVE effects
            createParticles(murry.x + 25, murry.y + 60, ['#8B4513', '#654321', '#3d2314'], 35, { spread: 25 });
            createParticles(murry.x + 25, murry.y + 50, ['#8B4513', '#5c3a1a'], 20, { spread: 30, vy: -5 });
            addStinkCloud(murry.x + 25, murry.y + 55, true);
            addStinkCloud(murry.x + 15, murry.y + 50, true);
            addStinkCloud(murry.x + 35, murry.y + 50, true);
            addFloatingText(murry.x + 25, murry.y - 60, getRandomQuote('relief'), '#4ade80', 26);
            addFloatingText(murry.x + 25, murry.y - 90, "+50 RELIEF!", '#ffd93d', 20);

            // EARTHQUAKE SHAKE
            screenShake.intensity = 35;

            // Sound sequence
            playSound('bigfart');
            setTimeout(() => {
                playSound('flush');
                screenShake.intensity = 20;
            }, 400);
            setTimeout(() => {
                playSound('relief');
                addFloatingText(murry.x + 25, murry.y - 30, "GLORIOUS!", '#4ade80', 18);
            }, 800);
        }
        updateEffects();
        updateHUD();
        return;
    }

    // ACCIDENT CHECK
    if (murry.belly >= 100) {
        murry.accidentTimer++;
        murry.faceRedness = Math.min(1, murry.accidentTimer / ACCIDENT_TIME);
        murry.eyeSize = 1 + murry.faceRedness * 0.6;

        // Panic effects
        if (murry.accidentTimer % 25 === 0) {
            murry.sweatDrops.push({ x: murry.x + 12 + Math.random() * 26, y: murry.y - 8, vy: 0 });
            addFloatingText(murry.x + 25, murry.y - 50, getRandomQuote('full'), '#ef4444', 15);
            if (Math.random() < 0.3) playSound('rumble');
        }

        // Emergency farts
        if (murry.accidentTimer > ACCIDENT_TIME * 0.4 && Math.random() < 0.025) {
            playSound('fart');
            addStinkCloud(murry.x + 25, murry.y + 55, false);
            addFloatingText(murry.x + 25, murry.y + 35, "*PFFFT*", '#8B4513', 13);
        }

        // ACCIDENT!
        if (murry.accidentTimer >= ACCIDENT_TIME) {
            gameOver('accident');
            return;
        }
    } else {
        murry.accidentTimer = Math.max(0, murry.accidentTimer - 1);
        murry.faceRedness = Math.max(0, murry.faceRedness - 0.015);
        murry.eyeSize = Math.max(1, murry.eyeSize - 0.025);
    }

    // === RAGE MODE ===
    if (murry.isRaging) {
        murry.rageTimer--;
        if (murry.rageTimer <= 0) {
            murry.isRaging = false;
            addFloatingText(murry.x + 25, murry.y - 50, "RAGE OVER", '#888', 16);
        }
    }

    // Movement (RAGE MODE = SUPER FAST!)
    const fatSlowdown = 1 - murry.fatness * 0.003; // Up to 30% slower when super fat
    const bellySlowdown = murry.belly > 80 ? 0.55 : murry.belly > 50 ? 0.75 : 1;
    const rageBoost = murry.isRaging ? 2.0 : 1; // DOUBLE SPEED IN RAGE MODE!
    const speedMod = fatSlowdown * bellySlowdown * rageBoost;

    if (keys['ArrowLeft'] || keys['KeyA']) {
        murry.vx = -murry.speed * speedMod;
        murry.facing = -1;
        murry.state = murry.onGround ? 'running' : 'jumping';
    } else if (keys['ArrowRight'] || keys['KeyD']) {
        murry.vx = murry.speed * speedMod;
        murry.facing = 1;
        murry.state = murry.onGround ? 'running' : 'jumping';
    } else {
        murry.vx *= FRICTION;
        if (murry.onGround && Math.abs(murry.vx) < 0.5) murry.state = 'idle';
    }

    // Jump (higher in rage mode!)
    if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && murry.onGround) {
        const jumpMod = murry.belly > 70 ? 0.75 : 1;
        const fatJumpMod = 1 - murry.fatness * 0.002;
        const rageJump = murry.isRaging ? 1.3 : 1; // 30% higher jumps in rage!
        murry.vy = murry.jumpPower * jumpMod * fatJumpMod * rageJump;
        murry.onGround = false;
        murry.state = 'jumping';
        playSound('jump');
        createParticles(murry.x + 25, murry.y + 70, murry.isRaging ? ['#ef4444', '#dc2626'] : ['#8B7355', '#a08060'], 7, { spread: 8 });
    }

    // === PUTTER COLLISION - TRIGGERS RAGE! ===
    for (let i = putters.length - 1; i >= 0; i--) {
        const putter = putters[i];
        if (!putter.broken &&
            murry.x < putter.x + putter.w && murry.x + murry.width > putter.x &&
            murry.y < putter.y + putter.h && murry.y + murry.height > putter.y) {

            // BREAK THE PUTTER!
            putter.broken = true;
            murry.puttersBroken++;
            murry.isRaging = true;
            murry.rageTimer = 300; // 5 seconds of rage at 60fps

            // RAGE EFFECTS!
            playSound('break');
            playSound('rage');
            screenShake.intensity = 25;

            // Putter pieces flying
            createParticles(putter.x + 25, putter.y + 10, ['#6b7280', '#9ca3af', '#374151'], 20, { spread: 20, vy: -6, spreadX: 8 });
            createParticles(putter.x + 25, putter.y + 10, ['#78350f', '#92400e'], 10, { spread: 15, vy: -4 }); // Wood/grip pieces

            // Rage text
            const quote = rageQuotes[Math.floor(Math.random() * rageQuotes.length)];
            addFloatingText(murry.x + 25, murry.y - 60, quote, '#ef4444', 24);
            addFloatingText(putter.x + 25, putter.y - 20, "üí¢ SNAP! üí¢", '#dc2626', 20);

            score += 200;
            addFloatingText(murry.x + 25, murry.y - 85, "+200 RAGE!", '#fbbf24', 18);

            // Remove broken putter after a moment
            setTimeout(() => {
                putters.splice(putters.indexOf(putter), 1);
            }, 100);
        }
    }

    // Physics
    murry.vy += GRAVITY;
    murry.x += murry.vx;
    murry.y += murry.vy;

    // Platform collision
    murry.onGround = false;
    for (const p of platforms) {
        if (murry.x + murry.width > p.x && murry.x < p.x + p.w &&
            murry.y + murry.height > p.y && murry.y + murry.height < p.y + p.h + 15 &&
            murry.vy >= 0) {
            murry.y = p.y - murry.height;
            if (murry.vy > 10) {
                screenShake.intensity = murry.vy * 0.4;
                createParticles(murry.x + 25, murry.y + 70, ['#8B7355'], 8);
            }
            murry.vy = 0;
            murry.onGround = true;
        }
    }

    // Screen bounds
    if (murry.x < 0) murry.x = 0;
    if (murry.x + murry.width > canvas.width) murry.x = canvas.width - murry.width;

    // Fall death
    if (murry.y > canvas.height + 60) {
        gameOver('fell');
        return;
    }

    // Collect food
    for (const food of foodItems) {
        if (!food.collected &&
            murry.x < food.x + food.w && murry.x + murry.width > food.x &&
            murry.y < food.y + food.h && murry.y + murry.height > food.y) {

            food.collected = true;
            totalItemsEaten++;
            murry.fatness = Math.min(100, murry.fatness + 2); // Get fatter!
            murry.mouthOpen = 12;

            let points = 0;
            let bellyAdd = 0;
            let hungerAdd = 0;
            let quoteType = 'eat';

            if (food.type === 'sandwich') {
                points = 100;
                bellyAdd = 25;
                hungerAdd = 28;
                quoteType = 'eat';
                createParticles(food.x + 20, food.y + 15, ['#FFD700', '#DEB887', '#32CD32'], 14);
            } else if (food.type === 'spicy') {
                points = 150;
                bellyAdd = 35; // Spicy = more belly
                hungerAdd = 32;
                quoteType = 'eatSpicy';
                createParticles(food.x + 20, food.y + 15, ['#ff4444', '#ff6b00', '#FFD700'], 16);
                // Spicy makes you sweat!
                murry.sweatDrops.push({ x: murry.x + 20, y: murry.y - 5, vy: 0 });
            } else if (food.type === 'fries') {
                points = 75;
                bellyAdd = 18;
                hungerAdd = 22;
                quoteType = 'eatFries';
                createParticles(food.x + 15, food.y + 15, ['#ffd93d', '#f59e0b', '#FFF8DC'], 12);
            }

            murry.belly = Math.min(100, murry.belly + bellyAdd);
            murry.hunger = Math.min(100, murry.hunger + hungerAdd);
            score += points;

            playSound('eat');
            if (murry.belly > 45 && Math.random() < 0.35) {
                setTimeout(() => {
                    playSound('burp');
                    addFloatingText(murry.x + 25, murry.y - 25, "*BURRRP*", '#90EE90', 15);
                }, 350);
            }

            addFloatingText(food.x + 20, food.y - 12, `+${points}`, '#ffd93d', 18);
            addFloatingText(murry.x + 25, murry.y - 55, getRandomQuote(quoteType), '#ffffff', 15);
            screenShake.intensity = 6;
        }
    }
    if (murry.mouthOpen > 0) murry.mouthOpen--;

    // Toilet interaction
    if (murry.belly >= 50 &&
        murry.x < toilet.x + toilet.w && murry.x + murry.width > toilet.x &&
        murry.y + murry.height > toilet.y && murry.y < toilet.y + toilet.h) {
        murry.state = 'pooping';
        murry.poopTimer = 0;
        murry.vx = 0;
    }

    // Respawn food when all collected
    if (foodItems.every(f => f.collected)) {
        spawnFood();
        addFloatingText(400, 150, "MORE CHICK-FIL-A!", '#e51636', 22);
    }

    // Update sweat
    murry.sweatDrops = murry.sweatDrops.filter(drop => {
        drop.vy += 0.35;
        drop.y += drop.vy;
        return drop.y < murry.y + 90;
    });

    updateEffects();
    updateHUD();
}

function gameOver(reason) {
    gameState = 'gameover';

    // Update high score
    const isNewRecord = score > highScore;
    if (isNewRecord) {
        highScore = score;
        localStorage.setItem('murryFuelHighScore', highScore);
    }

    let title, text, info;

    // Fat-based commentary
    const fatComment = murry.fatness > 80 ? "Murry was MASSIVE" :
                       murry.fatness > 50 ? "Murry got pretty chunky" :
                       murry.fatness > 25 ? "Murry was getting thicc" : "Murry stayed relatively slim";

    if (reason === 'accident') {
        playSound('accident');
        createParticles(murry.x + 25, murry.y + 60, ['#8B4513', '#654321'], 30, { spread: 20 });
        addStinkCloud(murry.x + 25, murry.y + 55, true);
        addFloatingText(murry.x + 25, murry.y - 50, getRandomQuote('accident'), '#ef4444', 24);
        screenShake.intensity = 25;

        const accidentTexts = [
            "Murry's khakis are ruined...",
            "The Chick-fil-A won this round",
            "That spicy sandwich caught up to him",
            "RIP Murry's underwear",
            "He who smelt it, dealt it... and worse"
        ];

        title = "üí© ACCIDENT! üí©";
        text = accidentTexts[Math.floor(Math.random() * accidentTexts.length)];
        info = `${fatComment}<br><br>üçó Items Eaten: ${totalItemsEaten}<br>üöΩ Successful Poops: ${totalPoops}<br>üèåÔ∏è Putters Broken: ${murry.puttersBroken}<br>üçî Final Fatness: ${Math.floor(murry.fatness)}%<br><br>SCORE: ${score}${isNewRecord ? '<br>üéâ NEW HIGH SCORE! üéâ' : ''}`;
    } else if (reason === 'starved') {
        playSound('gameover');

        const starveTexts = [
            "It's CLOSED SUNDAYS!",
            "The withdrawal symptoms got him",
            "No Chick-fil-A? No Murry.",
            "Murry needs his fix!",
            "The CFA addiction is terminal"
        ];

        title = "üòµ STARVED!";
        text = starveTexts[Math.floor(Math.random() * starveTexts.length)];
        info = `${fatComment}<br><br>üçó Items Eaten: ${totalItemsEaten}<br>üöΩ Successful Poops: ${totalPoops}<br>üèåÔ∏è Putters Broken: ${murry.puttersBroken}<br>üçî Final Fatness: ${Math.floor(murry.fatness)}%<br><br>SCORE: ${score}${isNewRecord ? '<br>üéâ NEW HIGH SCORE! üéâ' : ''}`;
    } else {
        playSound('gameover');

        const fellTexts = [
            "Too much chicken, not enough balance",
            "Gravity: 1, Murry: 0",
            "That belly threw off his center of gravity",
            "Should've done fewer waffle fries",
            "The floor is lava (and chicken grease)"
        ];

        title = "üíÄ FELL OFF!";
        text = fellTexts[Math.floor(Math.random() * fellTexts.length)];
        info = `${fatComment}<br><br>üçó Items Eaten: ${totalItemsEaten}<br>üöΩ Successful Poops: ${totalPoops}<br>üèåÔ∏è Putters Broken: ${murry.puttersBroken}<br>üçî Final Fatness: ${Math.floor(murry.fatness)}%<br><br>SCORE: ${score}${isNewRecord ? '<br>üéâ NEW HIGH SCORE! üéâ' : ''}`;
    }

    setTimeout(() => {
        showOverlay(title, text, info, "EAT AGAIN!", true);
    }, 1200);
}

function updateEffects() {
    if (screenShake.intensity > 0) {
        screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.intensity *= 0.88;
        if (screenShake.intensity < 0.5) screenShake.intensity = 0;
    }

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y += t.vy;
        if (t.vx) t.x += t.vx;
        if (t.isParticle) t.vy += 0.15;
        t.life -= t.decay;
        if (t.life <= 0) floatingTexts.splice(i, 1);
    }

    for (let i = stinkClouds.length - 1; i >= 0; i--) {
        const c = stinkClouds[i];
        c.x += c.vx;
        c.y += c.vy;
        c.rotation += 0.02;
        c.size *= 1.012;
        c.life -= c.decay;
        if (c.life <= 0) stinkClouds.splice(i, 1);
    }
}

// ============== DRAWING ==============
function drawBackground() {
    // Sky gradient - TURNS RED IN RAGE MODE!
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    if (murry.isRaging) {
        // RAGE RED SKY with pulsing effect
        const pulse = Math.sin(gameTime * 0.15) * 0.15 + 0.85;
        grad.addColorStop(0, `rgba(127, 29, 29, ${pulse})`);
        grad.addColorStop(0.4, `rgba(185, 28, 28, ${pulse})`);
        grad.addColorStop(0.8, `rgba(220, 38, 38, ${pulse})`);
        grad.addColorStop(1, `rgba(248, 113, 113, ${pulse})`);
    } else {
        grad.addColorStop(0, '#1e3a5f');
        grad.addColorStop(0.4, '#3b82b4');
        grad.addColorStop(0.8, '#7ec8e3');
        grad.addColorStop(1, '#b0d4e8');
    }
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Rage vignette effect
    if (murry.isRaging) {
        const vignette = ctx.createRadialGradient(400, 250, 100, 400, 250, 500);
        vignette.addColorStop(0, 'rgba(0,0,0,0)');
        vignette.addColorStop(1, 'rgba(139,0,0,0.4)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Sun
    ctx.save();
    const sunGlow = ctx.createRadialGradient(700, 80, 0, 700, 80, 90);
    sunGlow.addColorStop(0, 'rgba(255, 230, 120, 1)');
    sunGlow.addColorStop(0.4, 'rgba(255, 200, 80, 0.4)');
    sunGlow.addColorStop(1, 'rgba(255, 180, 50, 0)');
    ctx.fillStyle = sunGlow;
    ctx.beginPath();
    ctx.arc(700, 80, 90, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff5cc';
    ctx.beginPath();
    ctx.arc(700, 80, 35, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Clouds
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    [[60, 55, 1], [220, 90, 0.7], [400, 45, 1.1], [580, 85, 0.8], [750, 120, 0.6]].forEach(([x, y, scale]) => {
        ctx.save();
        ctx.translate(x + Math.sin(gameTime * 0.008 + x) * 3, y);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.arc(0, 0, 28, 0, Math.PI * 2);
        ctx.arc(28, -8, 22, 0, Math.PI * 2);
        ctx.arc(55, 0, 28, 0, Math.PI * 2);
        ctx.arc(28, 10, 20, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });

    // Chick-fil-A sign in background
    ctx.save();
    ctx.fillStyle = '#e51636';
    ctx.fillRect(30, 140, 80, 50);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 11px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Chick-fil-A', 70, 160);
    ctx.font = '8px Arial';
    ctx.fillText('OPEN', 70, 175);
    // Pole
    ctx.fillStyle = '#333';
    ctx.fillRect(65, 190, 10, 100);
    ctx.restore();

    // Cow with "EAT MOR CHIKIN" sign
    ctx.save();
    ctx.translate(650, 170);
    // Cow body
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(0, 0, 25, 18, 0, 0, Math.PI * 2);
    ctx.fill();
    // Cow spots
    ctx.fillStyle = '#1a1a1a';
    ctx.beginPath();
    ctx.ellipse(-10, -5, 8, 6, 0.3, 0, Math.PI * 2);
    ctx.ellipse(12, 2, 6, 5, -0.4, 0, Math.PI * 2);
    ctx.fill();
    // Cow head
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(25, -5, 12, 10, 0.2, 0, Math.PI * 2);
    ctx.fill();
    // Cow snout
    ctx.fillStyle = '#fcd9b6';
    ctx.beginPath();
    ctx.ellipse(32, -2, 6, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    // Cow eyes
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(24, -8, 2, 0, Math.PI * 2);
    ctx.arc(30, -7, 2, 0, Math.PI * 2);
    ctx.fill();
    // Sign held by cow
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(-40, -45, 60, 25);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(-40, -45, 60, 25);
    ctx.fillStyle = '#e51636';
    ctx.font = 'bold 9px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('EAT MOR', -10, -35);
    ctx.fillText('CHIKIN', -10, -25);
    ctx.restore();
}

function drawPlatforms() {
    for (const p of platforms) {
        if (p.type === 'grass') {
            const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            grad.addColorStop(0, '#4ade80');
            grad.addColorStop(0.2, '#22c55e');
            grad.addColorStop(1, '#15803d');
            ctx.fillStyle = grad;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Dirt
            ctx.fillStyle = '#92400e';
            ctx.fillRect(p.x, p.y + 10, p.w, p.h - 10);

            // Grass blades
            ctx.fillStyle = '#4ade80';
            for (let i = 0; i < p.w; i += 6) {
                const h = 6 + Math.sin(i * 0.4 + gameTime * 0.04) * 2;
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y);
                ctx.lineTo(p.x + i + 2, p.y - h);
                ctx.lineTo(p.x + i + 4, p.y);
                ctx.fill();
            }
        } else {
            const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            grad.addColorStop(0, '#d97706');
            grad.addColorStop(0.4, '#b45309');
            grad.addColorStop(1, '#78350f');
            ctx.fillStyle = grad;

            // Rounded rect
            const r = 5;
            ctx.beginPath();
            ctx.roundRect(p.x, p.y, p.w, p.h, r);
            ctx.fill();

            // Wood grain
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.lineWidth = 1;
            for (let i = 12; i < p.w; i += 18) {
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y + 3);
                ctx.lineTo(p.x + i, p.y + p.h - 3);
                ctx.stroke();
            }

            // Top highlight
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fillRect(p.x + 3, p.y + 2, p.w - 6, 3);
        }
    }
}

function drawToilet() {
    const t = toilet;
    const x = t.x, y = t.y;

    // Glow when needed
    if (murry.belly >= 50) {
        const urgency = murry.belly > 85 ? 1 : (murry.belly - 50) / 35;
        const pulse = Math.sin(gameTime * 0.12) * 0.3 + 0.7;
        ctx.shadowColor = murry.belly > 85 ? '#ef4444' : '#4ade80';
        ctx.shadowBlur = (15 + urgency * 15) * pulse;
    }

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(x + 30, y + 66, 28, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tank
    ctx.fillStyle = '#f8fafc';
    ctx.fillRect(x + 10, y, 40, 30);
    ctx.fillStyle = '#e2e8f0';
    ctx.fillRect(x + 10, y, 40, 6);

    // Tank lid
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 30, y + 3, 22, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Bowl
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 30, y + 50, 26, 16, 0, 0, Math.PI * 2);
    ctx.fill();

    // Inner bowl
    ctx.fillStyle = '#f1f5f9';
    ctx.beginPath();
    ctx.ellipse(x + 30, y + 50, 20, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // Water
    ctx.fillStyle = '#7dd3fc';
    ctx.beginPath();
    ctx.ellipse(x + 30, y + 52, 15, 8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Water shine
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.ellipse(x + 24, y + 49, 5, 2.5, -0.3, 0, Math.PI * 2);
    ctx.fill();

    // Seat
    ctx.fillStyle = '#f8fafc';
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(x + 30, y + 36, 22, 9, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Handle
    ctx.fillStyle = '#a1a1aa';
    ctx.fillRect(x + 48, y + 12, 12, 5);
    ctx.beginPath();
    ctx.arc(x + 60, y + 14, 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;

    // Sign
    ctx.fillStyle = murry.belly >= 50 ? '#e51636' : '#16a34a';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(murry.belly >= 50 ? 'üöΩ GO NOW!' : 'üöΩ RELIEF', x + 30, y - 10);
}

function drawFood(food) {
    if (food.collected) return;

    const bobY = Math.sin(gameTime * 0.07 + food.bob) * 4;
    const x = food.x, y = food.y + bobY;

    ctx.save();

    // Glow
    ctx.shadowColor = food.type === 'spicy' ? '#ef4444' : '#ffd93d';
    ctx.shadowBlur = 12 + Math.sin(gameTime * 0.08) * 4;

    if (food.type === 'fries') {
        // WAFFLE FRIES
        // Container
        ctx.fillStyle = '#e51636';
        ctx.beginPath();
        ctx.moveTo(x, y + 35);
        ctx.lineTo(x + 5, y + 12);
        ctx.lineTo(x + 25, y + 12);
        ctx.lineTo(x + 30, y + 35);
        ctx.closePath();
        ctx.fill();

        // Chick-fil-A logo on container
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 5px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('CFA', x + 15, y + 28);

        // Waffle fries sticking out
        ctx.fillStyle = '#fbbf24';
        for (let i = 0; i < 5; i++) {
            const fx = x + 5 + i * 5;
            const fy = y + 8 - Math.abs(i - 2) * 4;
            const fh = 12 + (i % 2) * 5;

            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.roundRect(fx, fy, 6, fh, 2);
            ctx.fill();

            // Waffle pattern
            ctx.strokeStyle = '#d97706';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(fx + 1, fy + 3);
            ctx.lineTo(fx + 5, fy + 3);
            ctx.moveTo(fx + 1, fy + 6);
            ctx.lineTo(fx + 5, fy + 6);
            ctx.moveTo(fx + 3, fy + 1);
            ctx.lineTo(fx + 3, fy + fh - 2);
            ctx.stroke();
        }
    } else {
        // CHICKEN SANDWICH
        const isSpicy = food.type === 'spicy';

        // Bottom bun
        ctx.fillStyle = '#d4a373';
        ctx.beginPath();
        ctx.ellipse(x + 20, y + 28, 19, 7, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#bc8a5f';
        ctx.beginPath();
        ctx.ellipse(x + 20, y + 30, 19, 5, 0, 0, Math.PI);
        ctx.fill();

        // Pickles
        ctx.fillStyle = '#65a30d';
        ctx.beginPath();
        ctx.ellipse(x + 12, y + 21, 5, 2.5, 0.3, 0, Math.PI * 2);
        ctx.ellipse(x + 28, y + 21, 5, 2.5, -0.3, 0, Math.PI * 2);
        ctx.fill();

        // CHICKEN PATTY
        ctx.fillStyle = isSpicy ? '#dc2626' : '#d97706';
        ctx.beginPath();
        ctx.ellipse(x + 20, y + 14, 17, 7, 0, 0, Math.PI * 2);
        ctx.fill();

        // Breading texture
        ctx.fillStyle = isSpicy ? '#991b1b' : '#b45309';
        for (let i = 0; i < 9; i++) {
            ctx.beginPath();
            ctx.arc(x + 8 + i * 3, y + 13 + (i % 2) * 3, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Spicy indicator
        if (isSpicy) {
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 6px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('üî•SPICYüî•', x + 20, y + 16);
        }

        // Top bun
        ctx.fillStyle = '#d4a373';
        ctx.beginPath();
        ctx.ellipse(x + 20, y + 5, 18, 10, 0, Math.PI, 2 * Math.PI);
        ctx.fill();
        ctx.fillRect(x + 2, y + 4, 36, 6);

        // Bun shine
        ctx.fillStyle = '#e8d4b8';
        ctx.beginPath();
        ctx.ellipse(x + 16, y + 1, 9, 4, -0.2, 0, Math.PI * 2);
        ctx.fill();

        // Sesame seeds (but not too many, like CFA)
        ctx.fillStyle = '#fef3c7';
        [[14, 0], [24, -1], [19, 4]].forEach(([ox, oy]) => {
            ctx.beginPath();
            ctx.ellipse(x + ox, y + oy, 2.5, 1.3, Math.random() * 0.5, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    ctx.shadowBlur = 0;
    ctx.restore();
}

function drawPutter(putter) {
    if (putter.broken) return;

    const bobY = Math.sin(gameTime * 0.05 + putter.bob) * 6;
    const x = putter.x;
    const y = putter.y + bobY;

    ctx.save();
    ctx.translate(x + 25, y + 10);
    ctx.rotate(putter.rotation + Math.sin(gameTime * 0.03) * 0.1);

    // Glow effect
    ctx.shadowColor = '#ef4444';
    ctx.shadowBlur = 15 + Math.sin(gameTime * 0.1) * 5;

    // Putter shaft (metallic gray)
    ctx.fillStyle = '#9ca3af';
    ctx.fillRect(-22, -3, 40, 6);

    // Shaft highlight
    ctx.fillStyle = '#d1d5db';
    ctx.fillRect(-22, -3, 40, 2);

    // Putter head (darker metal)
    ctx.fillStyle = '#4b5563';
    ctx.beginPath();
    ctx.roundRect(-25, -8, 12, 16, 2);
    ctx.fill();

    // Head face (hitting surface)
    ctx.fillStyle = '#374151';
    ctx.fillRect(-26, -6, 3, 12);

    // Grip (rubber/leather - brown)
    ctx.fillStyle = '#78350f';
    ctx.fillRect(15, -4, 12, 8);

    // Grip texture lines
    ctx.strokeStyle = '#451a03';
    ctx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(17 + i * 3, -4);
        ctx.lineTo(17 + i * 3, 4);
        ctx.stroke();
    }

    ctx.shadowBlur = 0;

    // "RAGE" label floating above
    ctx.fillStyle = '#ef4444';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('‚ö°RAGE‚ö°', 0, -18);

    ctx.restore();
}

function drawMurry() {
    const x = murry.x;
    const y = murry.y;
    const fatness = murry.fatness;
    const bellySize = (murry.belly / 100) * 18 + fatness * 0.15;

    ctx.save();

    if (murry.facing === -1) {
        ctx.translate(x + murry.width / 2, 0);
        ctx.scale(-1, 1);
        ctx.translate(-(x + murry.width / 2), 0);
    }

    // Animation
    let legOffset = 0;
    let armSwing = 0;
    let bodyBounce = 0;
    if (murry.state === 'running') {
        legOffset = Math.sin(murry.animFrame * 0.45) * 8;
        armSwing = Math.sin(murry.animFrame * 0.45) * 0.4;
        bodyBounce = Math.abs(Math.sin(murry.animFrame * 0.45)) * 3;
    }
    if (murry.state === 'dancing') {
        legOffset = Math.sin(murry.animFrame * 0.7) * 12;
        armSwing = Math.sin(murry.animFrame * 0.7) * 0.7;
        bodyBounce = Math.abs(Math.sin(murry.animFrame * 0.35)) * 5;
    }

    const breathOffset = Math.sin(gameTime * 0.05) * 1.5;

    // Shadow (gets bigger with fatness)
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.beginPath();
    ctx.ellipse(x + 25, y + 72 + fatness * 0.05, 20 + bellySize * 0.5, 6 + fatness * 0.02, 0, 0, Math.PI * 2);
    ctx.fill();

    // === GOLF SHOES ===
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 12, y + 62 - legOffset/2, 9, 5, 0, 0, Math.PI * 2);
    ctx.ellipse(x + 38, y + 62 + legOffset/2, 9, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#78350f';
    ctx.fillRect(x + 4, y + 64 - legOffset/2, 16, 5);
    ctx.fillRect(x + 30, y + 64 + legOffset/2, 16, 5);
    // Spikes
    ctx.fillStyle = '#1f2937';
    for (let i = 0; i < 3; i++) {
        ctx.fillRect(x + 6 + i * 5, y + 68 - legOffset/2, 2, 3);
        ctx.fillRect(x + 32 + i * 5, y + 68 + legOffset/2, 2, 3);
    }

    // === LEGS === (lighter/fairer skin tone like real Murry)
    ctx.fillStyle = '#ffe4cc';
    ctx.beginPath();
    ctx.moveTo(x + 14, y + 46);
    ctx.lineTo(x + 8, y + 60 - legOffset/2);
    ctx.lineTo(x + 18, y + 60 - legOffset/2);
    ctx.lineTo(x + 18, y + 46);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x + 32, y + 46);
    ctx.lineTo(x + 32, y + 60 + legOffset/2);
    ctx.lineTo(x + 42, y + 60 + legOffset/2);
    ctx.lineTo(x + 36, y + 46);
    ctx.fill();

    // === KHAKI SHORTS ===
    ctx.fillStyle = '#d4b896';
    ctx.beginPath();
    ctx.moveTo(x + 8, y + 34 - bodyBounce);
    ctx.lineTo(x + 42, y + 34 - bodyBounce);
    ctx.lineTo(x + 44, y + 50);
    ctx.lineTo(x + 6, y + 50);
    ctx.closePath();
    ctx.fill();
    // Belt
    ctx.fillStyle = '#78350f';
    ctx.fillRect(x + 8, y + 33 - bodyBounce, 34, 4);
    // Belt buckle
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(x + 22, y + 33 - bodyBounce, 6, 4);

    // === BELLY (THE MAIN EVENT - GETS HUGE!) ===
    const totalBelly = bellySize + breathOffset;
    ctx.fillStyle = '#ffe4cc'; // Lighter skin
    ctx.beginPath();
    ctx.ellipse(x + 25, y + 26 - bodyBounce, 18 + totalBelly, 16 + totalBelly * 0.9, 0, 0, Math.PI * 2);
    ctx.fill();

    // Belly button (more visible when fat)
    if (fatness > 20) {
        ctx.fillStyle = '#f5d5b8';
        ctx.beginPath();
        ctx.ellipse(x + 25, y + 32 - bodyBounce + totalBelly * 0.3, 2 + fatness * 0.02, 3 + fatness * 0.03, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // === FLORAL POLO === (White/blue like real Murry's shirt)
    const shirtStretch = totalBelly * 0.7;
    // White base, gets reddish when straining
    const shirtColor = murry.faceRedness > 0 ?
        `rgb(255, ${250 - murry.faceRedness * 50}, ${250 - murry.faceRedness * 60})` : '#f8fafc';

    ctx.fillStyle = shirtColor;
    ctx.beginPath();
    ctx.ellipse(x + 25, y + 22 - bodyBounce, 20 + shirtStretch, 17 + shirtStretch * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Shirt riding up when super fat (showing belly)
    if (fatness > 40) {
        ctx.fillStyle = '#ffe4cc';
        ctx.beginPath();
        ctx.ellipse(x + 25, y + 36 - bodyBounce, 12 + fatness * 0.1, 6 + fatness * 0.08, 0, 0, Math.PI);
        ctx.fill();
    }

    // Collar (white polo collar)
    ctx.fillStyle = '#e2e8f0';
    ctx.beginPath();
    ctx.moveTo(x + 18, y + 6 - bodyBounce);
    ctx.lineTo(x + 25, y + 14 - bodyBounce);
    ctx.lineTo(x + 32, y + 6 - bodyBounce);
    ctx.lineTo(x + 30, y + 4 - bodyBounce);
    ctx.lineTo(x + 25, y + 10 - bodyBounce);
    ctx.lineTo(x + 20, y + 4 - bodyBounce);
    ctx.closePath();
    ctx.fill();

    // Buttons
    ctx.fillStyle = '#ffffff';
    [16, 22, 28].forEach(dy => {
        ctx.beginPath();
        ctx.arc(x + 25, y + dy - bodyBounce, 2, 0, Math.PI * 2);
        ctx.fill();
    });

    // Blue/teal floral pattern (like real Murry's shirt)
    const flowers = [
        {dx: 12 - shirtStretch/4, dy: 18, c: '#0ea5e9', s: 4},      // Sky blue
        {dx: 36 + shirtStretch/4, dy: 16, c: '#06b6d4', s: 3.5},    // Cyan
        {dx: 22, dy: 30 + shirtStretch/2, c: '#0284c7', s: 4},      // Blue
        {dx: 14, dy: 32 + shirtStretch/2, c: '#0891b2', s: 3},      // Teal
        {dx: 35 + shirtStretch/4, dy: 28, c: '#38bdf8', s: 3.5},    // Light blue
        {dx: 18, dy: 12, c: '#22d3ee', s: 3},                        // Cyan
        {dx: 28, dy: 14, c: '#0ea5e9', s: 2.5},                      // Extra detail
    ];
    flowers.forEach(f => {
        ctx.fillStyle = f.c;
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2 + gameTime * 0.01;
            ctx.beginPath();
            ctx.ellipse(
                x + f.dx + Math.cos(angle) * f.s * 0.5,
                y + f.dy - bodyBounce + Math.sin(angle) * f.s * 0.5,
                f.s * 0.45, f.s * 0.3, angle, 0, Math.PI * 2
            );
            ctx.fill();
        }
        // White center
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(x + f.dx, y + f.dy - bodyBounce, f.s * 0.25, 0, Math.PI * 2);
        ctx.fill();
    });

    // Add some leaf/vine details in lighter blue
    ctx.strokeStyle = '#7dd3fc';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(x + 10, y + 24 - bodyBounce);
    ctx.quadraticCurveTo(x + 20, y + 20 - bodyBounce, x + 30, y + 26 - bodyBounce);
    ctx.stroke();

    // === ARMS === (lighter skin)
    ctx.fillStyle = '#ffe4cc';
    // Left arm
    ctx.save();
    ctx.translate(x + 6, y + 14 - bodyBounce);
    ctx.rotate(-0.3 + armSwing);
    ctx.beginPath();
    ctx.ellipse(0, 10, 6, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 22, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Right arm
    ctx.save();
    ctx.translate(x + 44, y + 14 - bodyBounce);
    ctx.rotate(0.3 - armSwing);
    ctx.beginPath();
    ctx.ellipse(0, 10, 6, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 22, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // === HEAD ===
    // Neck (gets thicker when fat)
    ctx.fillStyle = '#ffe4cc';
    ctx.fillRect(x + 20, y + 2 - bodyBounce, 10 + fatness * 0.05, 8);

    // Head (slightly bigger when fatter - double chin effect)
    const headScale = 1 + fatness * 0.002;
    ctx.save();
    ctx.translate(x + 25, y - 8 - bodyBounce);
    ctx.scale(headScale, headScale);

    ctx.fillStyle = '#ffe4cc'; // Light/fair skin like real Murry
    ctx.beginPath();
    ctx.ellipse(0, 0, 15, 13, 0, 0, Math.PI * 2);
    ctx.fill();

    // Double chin when fat
    if (fatness > 30) {
        ctx.beginPath();
        ctx.ellipse(0, 12, 8 + fatness * 0.08, 4 + fatness * 0.05, 0, 0, Math.PI);
        ctx.fill();
    }

    // Ears
    ctx.beginPath();
    ctx.ellipse(-14, 0, 4, 6, -0.2, 0, Math.PI * 2);
    ctx.ellipse(14, 0, 4, 6, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Face redness
    if (murry.faceRedness > 0) {
        ctx.fillStyle = `rgba(239, 68, 68, ${murry.faceRedness * 0.4})`;
        ctx.beginPath();
        ctx.ellipse(0, 0, 15, 13, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // === SNAPBACK CAP === (Black like "Bear Dance" cap)
    // Cap dome (draw first, behind brim)
    ctx.fillStyle = '#2d3748';
    ctx.beginPath();
    ctx.ellipse(0, -15, 16, 13, 0, Math.PI, 2 * Math.PI);
    ctx.fill();

    // Cap front panel (slightly lighter)
    ctx.fillStyle = '#374151';
    ctx.beginPath();
    ctx.ellipse(0, -16, 12, 10, 0, Math.PI, 2 * Math.PI);
    ctx.fill();

    // Cap button on top
    ctx.fillStyle = '#4a5568';
    ctx.beginPath();
    ctx.arc(0, -27, 3, 0, Math.PI * 2);
    ctx.fill();

    // Cap panel lines (stitching)
    ctx.strokeStyle = '#1a202c';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-7, -27);
    ctx.lineTo(-5, -10);
    ctx.moveTo(7, -27);
    ctx.lineTo(5, -10);
    ctx.stroke();

    // Brim (flat bill, draw on top)
    ctx.fillStyle = '#1a202c';
    ctx.beginPath();
    ctx.moveTo(-18, -10);
    ctx.quadraticCurveTo(-22, -6, -20, -2);
    ctx.lineTo(20, -2);
    ctx.quadraticCurveTo(22, -6, 18, -10);
    ctx.closePath();
    ctx.fill();

    // Brim underside (slightly visible)
    ctx.fillStyle = '#2d3748';
    ctx.beginPath();
    ctx.moveTo(-18, -9);
    ctx.lineTo(18, -9);
    ctx.lineTo(16, -7);
    ctx.lineTo(-16, -7);
    ctx.closePath();
    ctx.fill();

    // Hair peeking out from under cap (dark brown - more visible)
    ctx.fillStyle = '#5c4033';
    ctx.beginPath();
    ctx.ellipse(-13, -4, 5, 5, -0.3, 0, Math.PI * 2);
    ctx.ellipse(13, -4, 5, 5, 0.3, 0, Math.PI * 2);
    ctx.fill();
    // Sideburns (more prominent)
    ctx.fillStyle = '#4a3728';
    ctx.fillRect(-15, -2, 4, 8);
    ctx.fillRect(11, -2, 4, 8);

    // === MOUSTACHE === (Thinner/subtler like real Murry)
    ctx.fillStyle = '#4a3728'; // Dark brown (matching hair)
    // Simple thin moustache
    ctx.beginPath();
    ctx.moveTo(-8, 4);
    ctx.quadraticCurveTo(-4, 6, 0, 5);
    ctx.quadraticCurveTo(4, 6, 8, 4);
    ctx.quadraticCurveTo(4, 7, 0, 6);
    ctx.quadraticCurveTo(-4, 7, -8, 4);
    ctx.fill();

    // Eyes
    const eyeSize = 4.5 * murry.eyeSize;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(-6, -3, eyeSize, eyeSize * 0.85, 0, 0, Math.PI * 2);
    ctx.ellipse(6, -3, eyeSize, eyeSize * 0.85, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pupils
    const pupilOffset = murry.facing * 1.5;
    if (!murry.isBlinking) {
        ctx.fillStyle = '#422006';
        ctx.beginPath();
        ctx.arc(-6 + pupilOffset, -3, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.arc(6 + pupilOffset, -3, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Eye shine
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(-7 + pupilOffset, -4, eyeSize * 0.2, 0, Math.PI * 2);
        ctx.arc(5 + pupilOffset, -4, eyeSize * 0.2, 0, Math.PI * 2);
        ctx.fill();
    } else {
        ctx.strokeStyle = '#422006';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, -3);
        ctx.lineTo(-2, -3);
        ctx.moveTo(2, -3);
        ctx.lineTo(10, -3);
        ctx.stroke();
    }

    // Eyebrows (dark brown like real Murry)
    ctx.strokeStyle = '#4a3728';
    ctx.lineWidth = 2.5;
    if (murry.belly > 80 || murry.state === 'pooping') {
        ctx.beginPath();
        ctx.moveTo(-10, -10);
        ctx.lineTo(-3, -7);
        ctx.moveTo(3, -7);
        ctx.lineTo(10, -10);
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.moveTo(-10, -9);
        ctx.lineTo(-2, -9);
        ctx.moveTo(2, -9);
        ctx.lineTo(10, -9);
        ctx.stroke();
    }

    // Nose
    ctx.fillStyle = '#eab892';
    ctx.beginPath();
    ctx.ellipse(0, 1, 3.5, 2.5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Mouth
    ctx.strokeStyle = '#7c2d12';
    ctx.lineWidth = 2.5;
    ctx.lineCap = 'round';

    if (murry.mouthOpen > 0) {
        ctx.fillStyle = '#7c2d12';
        ctx.beginPath();
        ctx.ellipse(0, 10, 6, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.ellipse(0, 11, 4, 3, 0, 0, Math.PI);
        ctx.fill();
    } else if (murry.state === 'pooping') {
        ctx.beginPath();
        ctx.ellipse(0, 10, 5, 4, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-4, 9, 8, 3);
        ctx.strokeStyle = '#7c2d12';
        ctx.lineWidth = 1;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(-3 + i * 2, 9);
            ctx.lineTo(-3 + i * 2, 12);
            ctx.stroke();
        }
    } else if (murry.state === 'dancing') {
        ctx.beginPath();
        ctx.arc(0, 8, 7, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.stroke();
        // Rosy cheeks
        ctx.fillStyle = 'rgba(251, 146, 60, 0.5)';
        ctx.beginPath();
        ctx.ellipse(-10, 2, 4, 3, 0, 0, Math.PI * 2);
        ctx.ellipse(10, 2, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();
    } else if (murry.belly > 80) {
        ctx.beginPath();
        ctx.moveTo(-6, 10);
        ctx.lineTo(-3, 12);
        ctx.lineTo(0, 10);
        ctx.lineTo(3, 12);
        ctx.lineTo(6, 10);
        ctx.stroke();
    } else if (murry.hunger < 30) {
        ctx.beginPath();
        ctx.arc(0, 14, 5, 1.15 * Math.PI, 1.85 * Math.PI);
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(0, 8, 5, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.stroke();
    }

    ctx.restore(); // End head scale

    // Sweat drops
    ctx.fillStyle = '#7dd3fc';
    murry.sweatDrops.forEach(drop => {
        ctx.beginPath();
        ctx.moveTo(drop.x, drop.y);
        ctx.quadraticCurveTo(drop.x - 3, drop.y + 6, drop.x, drop.y + 10);
        ctx.quadraticCurveTo(drop.x + 3, drop.y + 6, drop.x, drop.y);
        ctx.fill();
    });

    // Status indicator
    if (murry.belly > 75) {
        const urgency = murry.belly > 95 ? 'üöΩüíÄüíÄ' : murry.belly > 85 ? 'üöΩ‚ùó‚ùó' : 'üöΩ‚ùó';
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = murry.belly > 95 ? '#ef4444' : '#f97316';
        ctx.textAlign = 'center';
        ctx.fillText(urgency, x + 25, y - 35 - bodyBounce);
    }

    ctx.restore();
}

function drawStinkClouds() {
    stinkClouds.forEach(cloud => {
        ctx.save();
        ctx.globalAlpha = cloud.life * 0.55;
        ctx.translate(cloud.x, cloud.y);
        ctx.rotate(cloud.rotation);

        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, cloud.size);
        gradient.addColorStop(0, 'rgba(132, 204, 22, 0.7)');
        gradient.addColorStop(0.5, 'rgba(101, 163, 13, 0.4)');
        gradient.addColorStop(1, 'rgba(77, 124, 15, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const wobble = Math.sin(i * 2.5 + cloud.rotation * 4) * cloud.size * 0.25;
            const r = cloud.size + wobble;
            if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
            else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }
        ctx.closePath();
        ctx.fill();

        // Stink lines
        ctx.strokeStyle = `rgba(101, 163, 13, ${cloud.life * 0.4})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            const startAngle = cloud.rotation + i * 2.1;
            ctx.moveTo(Math.cos(startAngle) * 4, Math.sin(startAngle) * 4);
            ctx.quadraticCurveTo(
                Math.cos(startAngle + 0.5) * cloud.size * 0.45,
                Math.sin(startAngle + 0.5) * cloud.size * 0.45 - 6,
                Math.cos(startAngle + 1) * cloud.size * 0.65,
                Math.sin(startAngle + 1) * cloud.size * 0.65 - 12
            );
            ctx.stroke();
        }

        ctx.restore();
    });
}

function drawFloatingTexts() {
    floatingTexts.forEach(t => {
        ctx.globalAlpha = t.life;
        if (t.isParticle) {
            ctx.fillStyle = t.color;
            ctx.beginPath();
            ctx.arc(t.x, t.y, t.size, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.font = `bold ${t.size}px Arial`;
            ctx.textAlign = 'center';
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillText(t.text, t.x + 2, t.y + 2);
            // Text
            ctx.fillStyle = t.color;
            ctx.fillText(t.text, t.x, t.y);
        }
    });
    ctx.globalAlpha = 1;
}

function draw() {
    ctx.save();
    ctx.translate(screenShake.x, screenShake.y);

    drawBackground();
    drawPlatforms();
    drawToilet();
    foodItems.forEach(f => drawFood(f));
    putters.forEach(p => drawPutter(p)); // Draw golf putters
    drawStinkClouds();
    drawMurry();
    drawFloatingTexts();

    // Rage mode border flash
    if (murry.isRaging) {
        ctx.strokeStyle = `rgba(239, 68, 68, ${0.5 + Math.sin(gameTime * 0.2) * 0.3})`;
        ctx.lineWidth = 8;
        ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
    }

    ctx.restore();
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// Start
setupMobileControls();
document.getElementById('highScoreDisplay').textContent = highScore;
showOverlay('üêî MURRY FUEL üêî',
    '"My pleasure... to eat ALL of it"',
    'Murry is ADDICTED to Chick-fil-A.<br><br>üçó Eat sandwiches & waffle fries<br>üî• Spicy ones fill you up faster!<br>üèåÔ∏è Break putters = MURRY RAGE!<br>üöΩ Get to the toilet before you EXPLODE<br>üíÄ Hold it too long = ACCIDENT!<br><br>How long can Murry last?',
    'EAT! MY PLEASURE!', true);
gameLoop();
</script>
</body>
</html>
