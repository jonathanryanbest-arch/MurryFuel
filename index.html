<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Murry Fuel - Chicken Sandwich Chase!</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }
        #gameContainer {
            text-align: center;
            position: relative;
            width: 100%;
            max-width: 850px;
            padding: 5px;
        }
        h1 {
            color: #ff6b35;
            font-size: clamp(1.2em, 5vw, 2.2em);
            margin-bottom: 3px;
            text-shadow: 2px 2px 0px #ffc300;
        }
        .subtitle {
            color: #ffc300;
            font-size: clamp(0.7em, 2.5vw, 0.9em);
            margin-bottom: 5px;
        }
        #hud {
            display: flex;
            justify-content: space-around;
            padding: 6px 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            margin-bottom: 5px;
            flex-wrap: wrap;
            gap: 5px;
        }
        .hud-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .hud-label {
            color: #aaa;
            font-size: clamp(0.6em, 2vw, 0.8em);
        }
        .hud-value {
            color: #ffc300;
            font-size: clamp(0.8em, 2.5vw, 1em);
            font-weight: bold;
        }
        .meter-container {
            width: clamp(60px, 15vw, 100px);
            height: 14px;
            background: #333;
            border-radius: 7px;
            overflow: hidden;
            border: 2px solid #555;
        }
        #hungerMeter {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8844);
            width: 100%;
            transition: width 0.3s;
        }
        #bellyMeter {
            height: 100%;
            background: linear-gradient(90deg, #44aa44, #ffcc00, #ff0000);
            width: 0%;
            transition: width 0.3s;
        }
        #canvasWrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }
        canvas {
            border: 3px solid #ff6b35;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
            display: block;
            width: 100%;
            height: auto;
            touch-action: none;
        }
        #instructions {
            color: #aaa;
            margin-top: 5px;
            font-size: clamp(0.6em, 2vw, 0.85em);
            padding: 0 10px;
        }
        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.92);
            padding: clamp(15px, 4vw, 35px);
            border-radius: 15px;
            border: 3px solid #ff6b35;
            z-index: 100;
            width: 90%;
            max-width: 400px;
        }
        #overlay h2 {
            color: #ff6b35;
            font-size: clamp(1.3em, 5vw, 1.8em);
            margin-bottom: 10px;
        }
        #overlay p {
            color: #ffc300;
            font-size: clamp(0.85em, 3vw, 1em);
            margin-bottom: 8px;
        }
        #overlay .info {
            color: #aaa;
            font-size: clamp(0.75em, 2.5vw, 0.9em);
            margin: 10px 0;
            line-height: 1.4;
        }
        #overlay button {
            background: #ff6b35;
            color: white;
            border: none;
            padding: clamp(10px, 3vw, 15px) clamp(25px, 8vw, 40px);
            font-size: clamp(1em, 3.5vw, 1.2em);
            border-radius: 10px;
            cursor: pointer;
            margin-top: 8px;
            -webkit-tap-highlight-color: transparent;
        }
        #overlay button:hover, #overlay button:active {
            background: #ff8855;
        }
        .hidden { display: none !important; }

        /* Mobile Controls */
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            z-index: 50;
        }
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 500px;
            margin: 0 auto;
        }
        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
            width: 130px;
        }
        .dpad-btn {
            width: 42px;
            height: 42px;
            background: rgba(255, 107, 53, 0.7);
            border: 2px solid #ff6b35;
            border-radius: 8px;
            color: white;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .dpad-btn:active, .dpad-btn.active {
            background: #ff6b35;
            transform: scale(0.95);
        }
        .dpad-btn.empty {
            visibility: hidden;
        }
        #jumpBtn {
            width: 90px;
            height: 90px;
            background: rgba(255, 199, 0, 0.7);
            border: 3px solid #ffc300;
            border-radius: 50%;
            color: white;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        #jumpBtn:active, #jumpBtn.active {
            background: #ffc300;
            transform: scale(0.95);
        }

        @media (hover: none) and (pointer: coarse) {
            #mobileControls { display: block; }
            #instructions { display: none; }
            #gameContainer { padding-bottom: 130px; }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            h1 { font-size: 1.2em; margin-bottom: 2px; }
            .subtitle { display: none; }
            #hud { padding: 4px 8px; gap: 3px; }
            .meter-container { width: 50px; height: 12px; }
            #mobileControls { padding: 5px; }
            .dpad-btn { width: 36px; height: 36px; font-size: 16px; }
            #jumpBtn { width: 70px; height: 70px; font-size: 12px; }
            #gameContainer { padding-bottom: 100px; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>üçó MURRY FUEL üçó</h1>
        <div class="subtitle">The Chicken Sandwich Chase!</div>
        <div id="hud">
            <div class="hud-item">
                <span class="hud-label">üçó</span>
                <span class="hud-value" id="scoreDisplay">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">üòã</span>
                <div class="meter-container"><div id="hungerMeter"></div></div>
            </div>
            <div class="hud-item">
                <span class="hud-label">ü§∞</span>
                <div class="meter-container"><div id="bellyMeter"></div></div>
            </div>
            <div class="hud-item">
                <span class="hud-label">üöΩ</span>
                <span class="hud-value" id="poopDisplay">0/2</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">‚≠ê</span>
                <span class="hud-value" id="levelDisplay">1</span>
            </div>
        </div>
        <div id="canvasWrapper">
            <canvas id="game" width="800" height="500"></canvas>
        </div>
        <div id="instructions">‚¨ÖÔ∏è‚û°Ô∏è Arrow Keys | SPACE Jump | Eat üçó ‚Üí Get full ‚Üí üöΩ ‚Üí Repeat!</div>

        <div id="overlay">
            <h2 id="overlayTitle">üçó MURRY FUEL üçó</h2>
            <p id="overlayText">Help Murry chase chicken sandwiches!</p>
            <div class="info" id="overlayInfo">Eat sandwiches ‚Üí Get full ‚Üí Find toilet ‚Üí Repeat!</div>
            <button id="overlayBtn">START GAME</button>
        </div>
    </div>

    <div id="mobileControls">
        <div class="control-row">
            <div class="dpad">
                <div class="dpad-btn empty"></div>
                <div class="dpad-btn" id="upBtn">‚¨ÜÔ∏è</div>
                <div class="dpad-btn empty"></div>
                <div class="dpad-btn" id="leftBtn">‚¨ÖÔ∏è</div>
                <div class="dpad-btn empty"></div>
                <div class="dpad-btn" id="rightBtn">‚û°Ô∏è</div>
            </div>
            <div id="jumpBtn">JUMP</div>
        </div>
    </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const overlayInfo = document.getElementById('overlayInfo');
const overlayBtn = document.getElementById('overlayBtn');

// ============== AUDIO SYSTEM ==============
let audioCtx = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

function playSound(type) {
    if (!audioCtx) return;

    try {
        switch(type) {
            case 'eat': {
                // Chomping sound
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.15);
                break;
            }
            case 'burp': {
                // Deep burp
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.2);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.5);
                break;
            }
            case 'fart': {
                // Fart sound - noise burst
                const bufferSize = audioCtx.sampleRate * 0.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.15));
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.4);
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.6, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);
                break;
            }
            case 'bigfart': {
                // Big relief fart
                const bufferSize = audioCtx.sampleRate * 1.2;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const env = Math.exp(-i / (bufferSize * 0.3));
                    const wobble = Math.sin(i / 500) * 0.5 + 0.5;
                    data[i] = (Math.random() * 2 - 1) * env * wobble;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 1);
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.7, audioCtx.currentTime);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);
                break;
            }
            case 'flush': {
                // Toilet flush - whooshing water
                const bufferSize = audioCtx.sampleRate * 2;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const progress = i / bufferSize;
                    const env = Math.sin(progress * Math.PI);
                    data[i] = (Math.random() * 2 - 1) * env;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(1000, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 2);
                filter.Q.value = 1;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start(audioCtx.currentTime);
                break;
            }
            case 'relief': {
                // Ahhhh sigh of relief
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.3);
                osc.frequency.exponentialRampToValueAtTime(250, audioCtx.currentTime + 0.8);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 1);
                break;
            }
            case 'accident': {
                // Oh no sound + wet splat
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.5);

                // Wet splat
                setTimeout(() => {
                    const bufferSize = audioCtx.sampleRate * 0.3;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
                    }
                    const noise = audioCtx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400;
                    const g = audioCtx.createGain();
                    g.gain.value = 0.5;
                    noise.connect(filter);
                    filter.connect(g);
                    g.connect(audioCtx.destination);
                    noise.start();
                }, 200);
                break;
            }
            case 'jump': {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.15);
                break;
            }
            case 'gasboost': {
                // Propulsion fart
                const bufferSize = audioCtx.sampleRate * 0.3;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i/bufferSize);
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 300;
                const gain = audioCtx.createGain();
                gain.gain.value = 0.4;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                noise.start();
                break;
            }
            case 'powerup': {
                const notes = [523, 659, 784];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.1 + 0.2);
                    osc.start(audioCtx.currentTime + i * 0.1);
                    osc.stop(audioCtx.currentTime + i * 0.1 + 0.2);
                });
                break;
            }
        }
    } catch(e) {
        console.log('Audio error:', e);
    }
}

// ============== GAME STATE ==============
let gameState = 'menu';
let score = 0;
let level = 1;
let poopsCompleted = 0;
let requiredPoops = 2;
let screenShake = { x: 0, y: 0, intensity: 0 };
let floatingTexts = [];
let stinkClouds = [];
let gameTime = 0;

// Murry quotes
const quotes = {
    eat: ["DELICIOUS!", "OH YEAH!", "NOM NOM!", "SO GOOD!", "CRISPY!", "WORTH IT!", "*CHOMP*", "YUMMY!"],
    full: ["OH NO...", "UH OH!", "GOTTA GO!", "PRAIRIE DOGGING!", "CODE BROWN!", "EMERGENCY!", "CLENCH!!", "HOLD IT!"],
    relief: ["AHHHHH!", "SWEET RELIEF!", "MUCH BETTER!", "THAT'S THE STUFF!", "GLORIOUS!", "FINALLY!", "YEEEESSS!"],
    accident: ["OOPS!", "NOT AGAIN!", "MY SHORTS!", "SHAME...", "OH DEAR!", "WHOOPSIE!"],
    hungry: ["NEED... FOOD...", "SO HUNGRY!", "FEED ME!", "STARVING!"]
};

function getRandomQuote(type) {
    const arr = quotes[type];
    return arr[Math.floor(Math.random() * arr.length)];
}

// Murry character
const murry = {
    x: 100, y: 350,
    width: 45, height: 65,
    vx: 0, vy: 0,
    speed: 5,
    jumpPower: -14,
    onGround: false,
    facing: 1,
    belly: 0,
    hunger: 100,
    state: 'idle',
    animFrame: 0,
    poopTimer: 0,
    accidentTimer: 0,
    danceTimer: 0,
    sweatDrops: [],
    gasCooldown: 0,
    eyeSize: 1,
    faceRedness: 0,
    hasAccident: false,
    // Power-ups
    tumsActive: 0,
    laxativeActive: 0,
    // New detailed properties
    breathOffset: 0,
    blinkTimer: 0,
    isBlinking: false,
    mouthOpen: 0
};

const GRAVITY = 0.55;
const FRICTION = 0.85;
const ACCIDENT_THRESHOLD = 100; // Belly level that triggers accident countdown
const ACCIDENT_TIME = 300; // Frames until accident (5 seconds at 60fps)

// Platforms, objects
let platforms = [];
let toilet = {};
let sandwiches = [];
let particles = [];
let powerups = [];

const keys = {};

// Level data
const levels = [
    {
        name: "The First Rumble",
        platforms: [
            {x: 0, y: 460, w: 800, h: 40, type: 'grass'},
            {x: 100, y: 380, w: 120, h: 18, type: 'wood'},
            {x: 300, y: 320, w: 120, h: 18, type: 'wood'},
            {x: 520, y: 380, w: 120, h: 18, type: 'wood'},
            {x: 200, y: 240, w: 100, h: 18, type: 'wood'},
            {x: 450, y: 200, w: 100, h: 18, type: 'wood'},
        ],
        toilet: {x: 700, y: 395, w: 55, h: 65},
        sandwiches: 5,
        poops: 2,
        hungerDecay: 0.025,
        powerups: ['tums']
    },
    {
        name: "Grumble in the Jungle",
        platforms: [
            {x: 0, y: 460, w: 800, h: 40, type: 'grass'},
            {x: 50, y: 385, w: 100, h: 18, type: 'wood'},
            {x: 200, y: 320, w: 100, h: 18, type: 'wood'},
            {x: 350, y: 255, w: 100, h: 18, type: 'wood'},
            {x: 500, y: 320, w: 100, h: 18, type: 'wood'},
            {x: 650, y: 385, w: 100, h: 18, type: 'wood'},
            {x: 300, y: 175, w: 120, h: 18, type: 'wood'},
        ],
        toilet: {x: 50, y: 395, w: 55, h: 65},
        sandwiches: 7,
        poops: 3,
        hungerDecay: 0.035,
        powerups: ['tums', 'laxative']
    },
    {
        name: "Code Brown Canyon",
        platforms: [
            {x: 0, y: 460, w: 200, h: 40, type: 'grass'},
            {x: 280, y: 460, w: 200, h: 40, type: 'grass'},
            {x: 560, y: 460, w: 240, h: 40, type: 'grass'},
            {x: 80, y: 380, w: 80, h: 18, type: 'wood'},
            {x: 220, y: 320, w: 80, h: 18, type: 'wood'},
            {x: 380, y: 260, w: 80, h: 18, type: 'wood'},
            {x: 540, y: 320, w: 80, h: 18, type: 'wood'},
            {x: 680, y: 380, w: 80, h: 18, type: 'wood'},
            {x: 150, y: 200, w: 100, h: 18, type: 'wood'},
            {x: 550, y: 180, w: 100, h: 18, type: 'wood'},
        ],
        toilet: {x: 370, y: 395, w: 55, h: 65},
        sandwiches: 10,
        poops: 4,
        hungerDecay: 0.04,
        powerups: ['tums', 'laxative', 'gasboost']
    }
];

let currentLevel = null;

// ============== FLOATING TEXT ==============
function addFloatingText(x, y, text, color = '#fff', size = 16) {
    floatingTexts.push({
        x, y, text, color, size,
        vy: -2,
        life: 1,
        decay: 0.015
    });
}

// ============== STINK CLOUDS ==============
function addStinkCloud(x, y, big = false) {
    const count = big ? 5 : 3;
    for (let i = 0; i < count; i++) {
        stinkClouds.push({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 10,
            size: big ? 15 + Math.random() * 20 : 8 + Math.random() * 12,
            vx: (Math.random() - 0.5) * 2,
            vy: -0.5 - Math.random() * 1,
            life: 1,
            decay: 0.008,
            rotation: Math.random() * Math.PI * 2
        });
    }
}

// ============== PARTICLES ==============
function createParticles(x, y, color, count, options = {}) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            vx: (options.vx || 0) + (Math.random() - 0.5) * (options.spread || 8),
            vy: (options.vy || 0) + (Math.random() - 0.5) * (options.spread || 8) - (options.lift || 3),
            life: 1,
            color: Array.isArray(color) ? color[Math.floor(Math.random() * color.length)] : color,
            size: (options.size || 3) + Math.random() * (options.sizeVar || 4),
            gravity: options.gravity !== undefined ? options.gravity : 0.2,
            type: options.type || 'circle'
        });
    }
}

// ============== LEVEL MANAGEMENT ==============
function loadLevel(num) {
    level = num;
    if (num > levels.length) {
        showOverlay('üéâ CHAMPION! üéâ', 'Murry conquered all the sandwiches!',
            `Final Score: ${score}\nTotal bathroom breaks survived!`, 'PLAY AGAIN');
        gameState = 'gameover';
        level = 1;
        return;
    }

    currentLevel = levels[num - 1];
    platforms = currentLevel.platforms.map(p => ({...p}));
    toilet = {...currentLevel.toilet};
    requiredPoops = currentLevel.poops;
    poopsCompleted = 0;

    // Reset Murry
    murry.x = 100;
    murry.y = 350;
    murry.vx = 0;
    murry.vy = 0;
    murry.belly = 0;
    murry.hunger = 100;
    murry.state = 'idle';
    murry.accidentTimer = 0;
    murry.hasAccident = false;
    murry.tumsActive = 0;
    murry.laxativeActive = 0;
    murry.faceRedness = 0;
    murry.eyeSize = 1;

    // Clear effects
    floatingTexts = [];
    stinkClouds = [];
    particles = [];

    spawnSandwiches();
    spawnPowerups();
    updateHUD();

    addFloatingText(400, 200, currentLevel.name, '#ffc300', 24);
}

function spawnSandwiches() {
    sandwiches = [];
    const validPlatforms = platforms.filter(p => p.w >= 80);
    for (let i = 0; i < currentLevel.sandwiches; i++) {
        const plat = validPlatforms[Math.floor(Math.random() * validPlatforms.length)];
        sandwiches.push({
            x: plat.x + 15 + Math.random() * (plat.w - 50),
            y: plat.y - 32,
            w: 38, h: 30,
            collected: false,
            bob: Math.random() * Math.PI * 2,
            rotation: (Math.random() - 0.5) * 0.2
        });
    }
}

function spawnPowerups() {
    powerups = [];
    if (!currentLevel.powerups) return;

    const validPlatforms = platforms.filter(p => p.w >= 80 && p.type === 'wood');
    currentLevel.powerups.forEach((type, i) => {
        if (validPlatforms.length > i) {
            const plat = validPlatforms[i];
            powerups.push({
                x: plat.x + plat.w/2 - 15,
                y: plat.y - 35,
                w: 30, h: 30,
                type,
                collected: false,
                bob: Math.random() * Math.PI * 2
            });
        }
    });
}

// ============== INPUT ==============
document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['Space', 'ArrowUp', 'ArrowDown'].includes(e.code)) e.preventDefault();
    initAudio();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

function setupMobileControls() {
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const upBtn = document.getElementById('upBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    function addTouchEvents(element, keyCode) {
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            keys[keyCode] = true;
            element.classList.add('active');
            initAudio();
        }, { passive: false });

        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[keyCode] = false;
            element.classList.remove('active');
        }, { passive: false });

        element.addEventListener('touchcancel', () => {
            keys[keyCode] = false;
            element.classList.remove('active');
        });
    }

    addTouchEvents(leftBtn, 'ArrowLeft');
    addTouchEvents(rightBtn, 'ArrowRight');
    addTouchEvents(upBtn, 'ArrowUp');
    addTouchEvents(jumpBtn, 'Space');
}

document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());

overlayBtn.addEventListener('click', handleOverlayClick);
overlayBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    handleOverlayClick();
});

function handleOverlayClick() {
    initAudio();
    if (gameState === 'menu' || gameState === 'gameover') {
        score = 0;
        loadLevel(1);
        gameState = 'playing';
        hideOverlay();
    } else if (gameState === 'levelcomplete') {
        loadLevel(level + 1);
        if (gameState !== 'gameover') {
            gameState = 'playing';
            hideOverlay();
        }
    }
}

function showOverlay(title, text, info, btn) {
    overlayTitle.textContent = title;
    overlayText.textContent = text;
    overlayInfo.textContent = info;
    overlayBtn.textContent = btn;
    overlay.classList.remove('hidden');
}

function hideOverlay() {
    overlay.classList.add('hidden');
}

function updateHUD() {
    document.getElementById('scoreDisplay').textContent = score;
    document.getElementById('hungerMeter').style.width = Math.max(0, murry.hunger) + '%';
    document.getElementById('bellyMeter').style.width = murry.belly + '%';
    document.getElementById('poopDisplay').textContent = poopsCompleted + '/' + requiredPoops;
    document.getElementById('levelDisplay').textContent = level;
}

// ============== UPDATE ==============
function update() {
    if (gameState !== 'playing') return;

    gameTime++;
    murry.animFrame++;
    murry.breathOffset = Math.sin(gameTime * 0.05) * 2;

    // Blinking
    murry.blinkTimer--;
    if (murry.blinkTimer <= 0) {
        if (murry.isBlinking) {
            murry.isBlinking = false;
            murry.blinkTimer = 120 + Math.random() * 180;
        } else {
            murry.isBlinking = true;
            murry.blinkTimer = 5;
        }
    }

    // Hunger decay
    murry.hunger -= currentLevel.hungerDecay;
    if (murry.hunger <= 0) {
        murry.hunger = 0;
        addFloatingText(murry.x + 20, murry.y - 30, getRandomQuote('hungry'), '#ff4444', 18);
        showOverlay('üòµ STARVED!', 'Murry ran out of fuel!', `Score: ${score}\n${getRandomQuote('hungry')}`, 'TRY AGAIN');
        gameState = 'gameover';
        return;
    }

    // Hungry warning
    if (murry.hunger < 25 && gameTime % 120 === 0) {
        addFloatingText(murry.x + 20, murry.y - 30, getRandomQuote('hungry'), '#ff8844', 14);
    }

    // Power-up timers
    if (murry.tumsActive > 0) murry.tumsActive--;
    if (murry.laxativeActive > 0) murry.laxativeActive--;
    if (murry.gasCooldown > 0) murry.gasCooldown--;

    // Victory dance state
    if (murry.state === 'dancing') {
        murry.danceTimer--;
        if (murry.danceTimer <= 0) {
            murry.state = 'idle';
        }
        updateHUD();
        updateEffects();
        return;
    }

    // Pooping state
    if (murry.state === 'pooping') {
        murry.poopTimer++;
        const poopDuration = murry.laxativeActive > 0 ? 45 : 90;

        // Add stink during pooping
        if (murry.poopTimer % 15 === 0) {
            addStinkCloud(murry.x + 20, murry.y + 50, true);
        }

        if (murry.poopTimer > poopDuration) {
            murry.belly = 0;
            murry.state = 'dancing';
            murry.danceTimer = 60;
            murry.accidentTimer = 0;
            murry.faceRedness = 0;
            poopsCompleted++;

            // Effects
            createParticles(murry.x + 20, murry.y + 55, ['#8B4513', '#654321', '#3d2314'], 20, { spread: 10, lift: 5 });
            addStinkCloud(murry.x + 20, murry.y + 50, true);
            addFloatingText(murry.x + 20, murry.y - 40, getRandomQuote('relief'), '#44ff44', 20);
            screenShake.intensity = 12;

            playSound('bigfart');
            setTimeout(() => playSound('flush'), 400);
            setTimeout(() => playSound('relief'), 800);

            if (poopsCompleted >= requiredPoops && sandwiches.every(s => s.collected)) {
                setTimeout(() => {
                    showOverlay('‚úÖ LEVEL COMPLETE!', `${currentLevel.name} conquered!`,
                        `Score: ${score}\n"${getRandomQuote('relief')}"`, 'NEXT LEVEL');
                    gameState = 'levelcomplete';
                }, 1000);
            }
        }
        updateHUD();
        updateEffects();
        return;
    }

    // ACCIDENT MECHANIC
    const bellyThreshold = murry.tumsActive > 0 ? 120 : ACCIDENT_THRESHOLD;
    if (murry.belly >= bellyThreshold && murry.state !== 'pooping') {
        murry.accidentTimer++;
        murry.faceRedness = Math.min(1, murry.accidentTimer / ACCIDENT_TIME);
        murry.eyeSize = 1 + murry.faceRedness * 0.5;

        // Sweat and panic
        if (murry.accidentTimer % 30 === 0) {
            murry.sweatDrops.push({ x: murry.x + 10 + Math.random() * 20, y: murry.y - 5, vy: 0 });
            addFloatingText(murry.x + 20, murry.y - 40, getRandomQuote('full'), '#ff0000', 14);
        }

        // Random emergency farts
        if (murry.accidentTimer > ACCIDENT_TIME * 0.5 && Math.random() < 0.02) {
            playSound('fart');
            addStinkCloud(murry.x + 20, murry.y + 50, false);
            addFloatingText(murry.x + 20, murry.y + 30, "*PFFFT*", '#8B4513', 12);
        }

        // ACCIDENT!
        if (murry.accidentTimer >= ACCIDENT_TIME) {
            murry.hasAccident = true;
            murry.belly = 0;
            murry.accidentTimer = 0;
            murry.faceRedness = 0;
            score = Math.max(0, score - 200);

            playSound('accident');
            createParticles(murry.x + 20, murry.y + 55, ['#8B4513', '#654321'], 25, { spread: 15, lift: 2 });
            addStinkCloud(murry.x + 20, murry.y + 50, true);
            addFloatingText(murry.x + 20, murry.y - 40, getRandomQuote('accident'), '#ff0000', 22);
            addFloatingText(murry.x + 20, murry.y - 60, "-200 PTS", '#ff0000', 16);
            screenShake.intensity = 20;

            // Brown trail marker
            createParticles(murry.x + 20, murry.y + 60, '#5c3d2e', 10, { spread: 5, gravity: 0, lift: 0 });
        }
    } else {
        murry.accidentTimer = Math.max(0, murry.accidentTimer - 0.5);
        murry.faceRedness = Math.max(0, murry.faceRedness - 0.01);
        murry.eyeSize = Math.max(1, murry.eyeSize - 0.02);
    }

    // Movement
    const bellySlowdown = murry.belly > 80 ? 0.45 : murry.belly > 50 ? 0.7 : 1;
    const speedMod = bellySlowdown;

    if (keys['ArrowLeft'] || keys['KeyA']) {
        murry.vx = -murry.speed * speedMod;
        murry.facing = -1;
        murry.state = murry.onGround ? 'running' : 'jumping';
    } else if (keys['ArrowRight'] || keys['KeyD']) {
        murry.vx = murry.speed * speedMod;
        murry.facing = 1;
        murry.state = murry.onGround ? 'running' : 'jumping';
    } else {
        murry.vx *= FRICTION;
        if (murry.onGround && Math.abs(murry.vx) < 0.5) murry.state = 'idle';
    }

    // Jump
    if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && murry.onGround) {
        const jumpMod = murry.belly > 70 ? 0.7 : 1;
        murry.vy = murry.jumpPower * jumpMod;
        murry.onGround = false;
        murry.state = 'jumping';
        playSound('jump');
        createParticles(murry.x + 22, murry.y + 65, '#8B7355', 6, { spread: 4, lift: 1 });

        // Gas boost jump when belly is high
        if (murry.belly > 60 && murry.gasCooldown <= 0) {
            murry.vy -= 4;
            murry.gasCooldown = 60;
            playSound('gasboost');
            addStinkCloud(murry.x + 20, murry.y + 60, true);
            addFloatingText(murry.x + 20, murry.y + 40, "GAS BOOST!", '#88ff88', 14);
        }
    }

    // Physics
    murry.vy += GRAVITY;
    murry.x += murry.vx;
    murry.y += murry.vy;

    // Platform collision
    murry.onGround = false;
    for (const p of platforms) {
        if (murry.x + murry.width > p.x && murry.x < p.x + p.w &&
            murry.y + murry.height > p.y && murry.y + murry.height < p.y + p.h + 15 &&
            murry.vy >= 0) {
            murry.y = p.y - murry.height;
            if (murry.vy > 8) {
                screenShake.intensity = murry.vy * 0.5;
                createParticles(murry.x + 22, murry.y + 65, '#8B7355', 8);
            }
            murry.vy = 0;
            murry.onGround = true;
        }
    }

    // Screen bounds
    if (murry.x < 0) murry.x = 0;
    if (murry.x + murry.width > canvas.width) murry.x = canvas.width - murry.width;

    // Fall death
    if (murry.y > canvas.height + 50) {
        showOverlay('üíÄ FELL OFF!', 'Murry took a tumble!', `Score: ${score}`, 'TRY AGAIN');
        gameState = 'gameover';
        return;
    }

    // Collect sandwiches
    const maxBelly = murry.tumsActive > 0 ? 120 : 100;
    for (const s of sandwiches) {
        if (!s.collected && murry.belly < maxBelly &&
            murry.x < s.x + s.w && murry.x + murry.width > s.x &&
            murry.y < s.y + s.h && murry.y + murry.height > s.y) {
            s.collected = true;
            murry.belly = Math.min(maxBelly, murry.belly + 28);
            murry.hunger = Math.min(100, murry.hunger + 30);
            murry.mouthOpen = 10;
            score += 100;

            playSound('eat');
            if (murry.belly > 50 && Math.random() < 0.4) {
                setTimeout(() => playSound('burp'), 300);
                setTimeout(() => addFloatingText(murry.x + 20, murry.y - 20, "*BURRRP*", '#88cc44', 14), 300);
            }

            createParticles(s.x + 19, s.y + 15, ['#FFD700', '#FFA500', '#DEB887'], 12);
            addFloatingText(s.x + 19, s.y - 10, "+100", '#ffc300', 16);
            addFloatingText(murry.x + 20, murry.y - 50, getRandomQuote('eat'), '#ffffff', 14);
            screenShake.intensity = 5;
        }
    }
    if (murry.mouthOpen > 0) murry.mouthOpen--;

    // Collect powerups
    for (const p of powerups) {
        if (!p.collected &&
            murry.x < p.x + p.w && murry.x + murry.width > p.x &&
            murry.y < p.y + p.h && murry.y + murry.height > p.y) {
            p.collected = true;
            playSound('powerup');
            createParticles(p.x + 15, p.y + 15, '#00ffff', 15);
            score += 50;

            if (p.type === 'tums') {
                murry.tumsActive = 600; // 10 seconds
                addFloatingText(p.x + 15, p.y - 10, "TUMS! +Belly Capacity", '#ff69b4', 14);
            } else if (p.type === 'laxative') {
                murry.laxativeActive = 600;
                addFloatingText(p.x + 15, p.y - 10, "LAXATIVE! Fast Relief", '#9932cc', 14);
            } else if (p.type === 'gasboost') {
                murry.gasCooldown = 0;
                murry.belly = Math.min(100, murry.belly + 30);
                addFloatingText(p.x + 15, p.y - 10, "BEAN BURRITO! +Gas", '#228b22', 14);
            }
        }
    }

    // Toilet interaction
    const minBelly = murry.laxativeActive > 0 ? 30 : 50;
    if (murry.belly >= minBelly &&
        murry.x < toilet.x + toilet.w && murry.x + murry.width > toilet.x &&
        murry.y < toilet.y + toilet.h && murry.y + murry.height > toilet.y) {
        murry.state = 'pooping';
        murry.poopTimer = 0;
        murry.vx = 0;
        murry.vy = 0;
    }

    // Respawn sandwiches
    if (sandwiches.every(s => s.collected) && poopsCompleted < requiredPoops) {
        spawnSandwiches();
        addFloatingText(400, 200, "MORE SANDWICHES!", '#ffc300', 20);
    }

    // Update sweat drops
    murry.sweatDrops = murry.sweatDrops.filter(drop => {
        drop.vy += 0.3;
        drop.y += drop.vy;
        return drop.y < murry.y + 80;
    });

    updateEffects();
    updateHUD();
}

function updateEffects() {
    // Screen shake
    if (screenShake.intensity > 0) {
        screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.intensity *= 0.9;
        if (screenShake.intensity < 0.5) screenShake.intensity = 0;
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity;
        p.life -= 0.02;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Floating texts
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        const t = floatingTexts[i];
        t.y += t.vy;
        t.life -= t.decay;
        if (t.life <= 0) floatingTexts.splice(i, 1);
    }

    // Stink clouds
    for (let i = stinkClouds.length - 1; i >= 0; i--) {
        const c = stinkClouds[i];
        c.x += c.vx;
        c.y += c.vy;
        c.rotation += 0.02;
        c.size *= 1.01;
        c.life -= c.decay;
        if (c.life <= 0) stinkClouds.splice(i, 1);
    }
}

// ============== DRAWING ==============
function drawBackground() {
    // Sky gradient
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#2d5a87');
    grad.addColorStop(0.5, '#5a9fd4');
    grad.addColorStop(1, '#87ceeb');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Sun with glow
    ctx.save();
    const sunGlow = ctx.createRadialGradient(720, 70, 0, 720, 70, 80);
    sunGlow.addColorStop(0, 'rgba(255, 220, 100, 1)');
    sunGlow.addColorStop(0.5, 'rgba(255, 180, 50, 0.3)');
    sunGlow.addColorStop(1, 'rgba(255, 150, 0, 0)');
    ctx.fillStyle = sunGlow;
    ctx.beginPath();
    ctx.arc(720, 70, 80, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#FFE484';
    ctx.beginPath();
    ctx.arc(720, 70, 35, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Clouds with depth
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    [[80, 50, 1], [250, 80, 0.7], [450, 35, 1.2], [620, 90, 0.8]].forEach(([x, y, scale]) => {
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.arc(0, 0, 25, 0, Math.PI * 2);
        ctx.arc(25, -8, 20, 0, Math.PI * 2);
        ctx.arc(50, 0, 25, 0, Math.PI * 2);
        ctx.arc(25, 8, 18, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });

    // Distant hills
    ctx.fillStyle = '#4a7c59';
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    ctx.quadraticCurveTo(200, canvas.height - 100, 400, canvas.height - 60);
    ctx.quadraticCurveTo(600, canvas.height - 120, 800, canvas.height - 40);
    ctx.lineTo(800, canvas.height);
    ctx.fill();
}

function drawPlatforms() {
    for (const p of platforms) {
        if (p.type === 'grass') {
            // Grass platform with detail
            const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            grad.addColorStop(0, '#4a8c4a');
            grad.addColorStop(0.3, '#3d7a3d');
            grad.addColorStop(1, '#2d5a2d');
            ctx.fillStyle = grad;
            ctx.fillRect(p.x, p.y, p.w, p.h);

            // Dirt layer
            ctx.fillStyle = '#8B6914';
            ctx.fillRect(p.x, p.y + 8, p.w, p.h - 8);

            // Grass blades
            ctx.fillStyle = '#5cb85c';
            for (let i = 0; i < p.w; i += 8) {
                const h = 5 + Math.sin(i * 0.5 + gameTime * 0.05) * 2;
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y);
                ctx.lineTo(p.x + i + 2, p.y - h);
                ctx.lineTo(p.x + i + 4, p.y);
                ctx.fill();
            }
        } else {
            // Wooden platform
            const grad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            grad.addColorStop(0, '#b8860b');
            grad.addColorStop(0.5, '#8b6914');
            grad.addColorStop(1, '#6b4423');
            ctx.fillStyle = grad;

            // Rounded rect
            const r = 4;
            ctx.beginPath();
            ctx.moveTo(p.x + r, p.y);
            ctx.lineTo(p.x + p.w - r, p.y);
            ctx.quadraticCurveTo(p.x + p.w, p.y, p.x + p.w, p.y + r);
            ctx.lineTo(p.x + p.w, p.y + p.h - r);
            ctx.quadraticCurveTo(p.x + p.w, p.y + p.h, p.x + p.w - r, p.y + p.h);
            ctx.lineTo(p.x + r, p.y + p.h);
            ctx.quadraticCurveTo(p.x, p.y + p.h, p.x, p.y + p.h - r);
            ctx.lineTo(p.x, p.y + r);
            ctx.quadraticCurveTo(p.x, p.y, p.x + r, p.y);
            ctx.fill();

            // Wood grain
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < p.w; i += 15) {
                ctx.beginPath();
                ctx.moveTo(p.x + i, p.y + 4);
                ctx.lineTo(p.x + i, p.y + p.h - 4);
                ctx.stroke();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255,255,255,0.2)';
            ctx.fillRect(p.x + 2, p.y + 2, p.w - 4, 3);
        }
    }
}

function drawToilet() {
    const t = toilet;
    const x = t.x;
    const y = t.y;

    // Pulsing glow when needed
    if (murry.belly >= 50) {
        const pulse = Math.sin(gameTime * 0.1) * 0.3 + 0.7;
        ctx.shadowColor = murry.belly > 80 ? '#ff0000' : '#00ff00';
        ctx.shadowBlur = 20 * pulse;
    }

    // Base shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x + 27, y + 62, 25, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Tank
    ctx.fillStyle = '#f0f0f0';
    ctx.fillRect(x + 10, y, 35, 28);
    ctx.fillStyle = '#e0e0e0';
    ctx.fillRect(x + 10, y, 35, 5);

    // Tank lid
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 27, y + 2, 18, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Bowl
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 27, y + 48, 24, 14, 0, 0, Math.PI * 2);
    ctx.fill();

    // Inner bowl
    ctx.fillStyle = '#e8f4f8';
    ctx.beginPath();
    ctx.ellipse(x + 27, y + 48, 18, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // Water
    ctx.fillStyle = '#a8d8ea';
    ctx.beginPath();
    ctx.ellipse(x + 27, y + 50, 14, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    // Water shine
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.beginPath();
    ctx.ellipse(x + 22, y + 47, 4, 2, -0.3, 0, Math.PI * 2);
    ctx.fill();

    // Seat
    ctx.fillStyle = '#f8f8f8';
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#ddd';
    ctx.beginPath();
    ctx.ellipse(x + 27, y + 35, 20, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Flush handle
    ctx.fillStyle = '#c0c0c0';
    ctx.fillRect(x + 42, y + 10, 10, 4);
    ctx.beginPath();
    ctx.arc(x + 52, y + 12, 5, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;

    // Sign
    ctx.fillStyle = '#228b22';
    ctx.font = 'bold 11px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('üöΩ RELIEF STATION', x + 27, y - 8);

    // Toilet paper roll
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(x + 50, y + 25, 8, 15);
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath();
    ctx.arc(x + 54, y + 25, 4, 0, Math.PI * 2);
    ctx.fill();

    // "Empty" sign on TP
    ctx.fillStyle = '#ff0000';
    ctx.font = 'bold 5px Arial';
    ctx.fillText('EMPTY', x + 54, y + 33);
}

function drawSandwich(s) {
    if (s.collected) return;

    const bobY = Math.sin(gameTime * 0.08 + s.bob) * 4;
    const x = s.x;
    const y = s.y + bobY;

    ctx.save();
    ctx.translate(x + 19, y + 15);
    ctx.rotate(s.rotation + Math.sin(gameTime * 0.05) * 0.05);
    ctx.translate(-19, -15);

    // Glow
    ctx.shadowColor = '#FFD700';
    ctx.shadowBlur = 15 + Math.sin(gameTime * 0.1) * 5;

    // Bottom bun
    ctx.fillStyle = '#e8c373';
    ctx.beginPath();
    ctx.ellipse(19, 26, 18, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#c9a55a';
    ctx.beginPath();
    ctx.ellipse(19, 28, 18, 5, 0, 0, Math.PI);
    ctx.fill();

    // Pickles
    ctx.fillStyle = '#5a8f3e';
    ctx.beginPath();
    ctx.ellipse(10, 20, 4, 2, 0.3, 0, Math.PI * 2);
    ctx.ellipse(28, 20, 4, 2, -0.3, 0, Math.PI * 2);
    ctx.fill();

    // Tomato
    ctx.fillStyle = '#e74c3c';
    ctx.beginPath();
    ctx.ellipse(19, 19, 8, 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Lettuce
    ctx.fillStyle = '#7dce82';
    for (let i = 0; i < 6; i++) {
        ctx.beginPath();
        ctx.arc(5 + i * 5, 17, 5, 0, Math.PI * 2);
        ctx.fill();
    }

    // CRISPY CHICKEN PATTY
    ctx.fillStyle = '#d4a543';
    ctx.beginPath();
    ctx.ellipse(19, 12, 16, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Crispy texture
    ctx.fillStyle = '#c49432';
    for (let i = 0; i < 8; i++) {
        ctx.beginPath();
        ctx.arc(7 + i * 3, 11 + (i % 2) * 2, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    // Top bun
    ctx.fillStyle = '#e8c373';
    ctx.beginPath();
    ctx.ellipse(19, 5, 17, 9, 0, Math.PI, 2 * Math.PI);
    ctx.fill();
    ctx.fillRect(2, 4, 34, 5);

    // Bun shine
    ctx.fillStyle = '#f5dfa0';
    ctx.beginPath();
    ctx.ellipse(15, 2, 8, 3, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // Sesame seeds
    ctx.fillStyle = '#fffacd';
    [[12, 0], [22, -1], [17, 3], [26, 2], [9, 3]].forEach(([ox, oy]) => {
        ctx.beginPath();
        ctx.ellipse(ox, oy, 2.5, 1.2, Math.random() * 0.5, 0, Math.PI * 2);
        ctx.fill();
    });

    ctx.shadowBlur = 0;

    // CHICKEN label with better visibility
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(6, 9, 26, 8);
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 7px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('CHICKEN', 19, 15);

    ctx.restore();
}

function drawPowerup(p) {
    if (p.collected) return;

    const bobY = Math.sin(gameTime * 0.1 + p.bob) * 5;
    const x = p.x;
    const y = p.y + bobY;

    ctx.save();

    // Glow and rotation
    const colors = {
        tums: '#ff69b4',
        laxative: '#9932cc',
        gasboost: '#228b22'
    };

    ctx.shadowColor = colors[p.type];
    ctx.shadowBlur = 12;

    ctx.translate(x + 15, y + 15);
    ctx.rotate(gameTime * 0.03);
    ctx.translate(-15, -15);

    // Box
    ctx.fillStyle = colors[p.type];
    ctx.fillRect(0, 0, 30, 30);

    // Icon
    ctx.fillStyle = '#ffffff';
    ctx.font = '18px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const icons = { tums: 'üíä', laxative: 'üí©', gasboost: 'üåØ' };
    ctx.fillText(icons[p.type], 15, 15);

    ctx.restore();
}

function drawMurry() {
    const x = murry.x;
    const y = murry.y + murry.breathOffset;
    const bellySize = (murry.belly / 100) * 15;

    ctx.save();

    // Flip if facing left
    if (murry.facing === -1) {
        ctx.translate(x + murry.width / 2, 0);
        ctx.scale(-1, 1);
        ctx.translate(-(x + murry.width / 2), 0);
    }

    // Animation calculations
    let legOffset = 0;
    let armSwing = 0;
    if (murry.state === 'running') {
        legOffset = Math.sin(murry.animFrame * 0.5) * 8;
        armSwing = Math.sin(murry.animFrame * 0.5) * 0.4;
    }
    if (murry.state === 'dancing') {
        legOffset = Math.sin(murry.animFrame * 0.8) * 10;
        armSwing = Math.sin(murry.animFrame * 0.8) * 0.6;
    }

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(x + 22, y + 68, 18 + bellySize/2, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Brown stain if accident happened
    if (murry.hasAccident) {
        ctx.fillStyle = 'rgba(101, 67, 33, 0.6)';
        ctx.beginPath();
        ctx.ellipse(x + 22, y + 45, 8, 12, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // === GOLF SHOES ===
    // Left shoe
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 10, y + 58 - legOffset/2, 8, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(x + 3, y + 60 - legOffset/2, 14, 4);
    // Spikes
    ctx.fillStyle = '#333';
    for (let i = 0; i < 3; i++) {
        ctx.fillRect(x + 5 + i * 4, y + 63 - legOffset/2, 2, 3);
    }

    // Right shoe
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 32, y + 58 + legOffset/2, 8, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(x + 25, y + 60 + legOffset/2, 14, 4);
    ctx.fillStyle = '#333';
    for (let i = 0; i < 3; i++) {
        ctx.fillRect(x + 27 + i * 4, y + 63 + legOffset/2, 2, 3);
    }

    // === LEGS ===
    ctx.fillStyle = '#fdbf6f';
    // Left leg
    ctx.beginPath();
    ctx.moveTo(x + 12, y + 42);
    ctx.lineTo(x + 6, y + 55 - legOffset/2);
    ctx.lineTo(x + 14, y + 55 - legOffset/2);
    ctx.lineTo(x + 16, y + 42);
    ctx.fill();
    // Right leg
    ctx.beginPath();
    ctx.moveTo(x + 28, y + 42);
    ctx.lineTo(x + 30, y + 55 + legOffset/2);
    ctx.lineTo(x + 38, y + 55 + legOffset/2);
    ctx.lineTo(x + 32, y + 42);
    ctx.fill();

    // === KHAKI SHORTS ===
    ctx.fillStyle = '#c3b091';
    ctx.beginPath();
    ctx.moveTo(x + 8, y + 32);
    ctx.lineTo(x + 36, y + 32);
    ctx.lineTo(x + 38, y + 46);
    ctx.lineTo(x + 6, y + 46);
    ctx.closePath();
    ctx.fill();
    // Shorts seam
    ctx.strokeStyle = '#a69070';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + 22, y + 32);
    ctx.lineTo(x + 22, y + 46);
    ctx.stroke();
    // Pocket
    ctx.strokeStyle = '#a69070';
    ctx.beginPath();
    ctx.arc(x + 32, y + 38, 5, 0.5, 2.5);
    ctx.stroke();

    // === BELLY (grows!) ===
    ctx.fillStyle = '#fdbf6f';
    ctx.beginPath();
    ctx.ellipse(x + 22, y + 26, 16 + bellySize, 14 + bellySize * 0.8, 0, 0, Math.PI * 2);
    ctx.fill();

    // === FLORAL POLO SHIRT ===
    // Main shirt (pink, stretches with belly)
    const shirtPink = murry.faceRedness > 0 ?
        `rgb(${255}, ${105 - murry.faceRedness * 50}, ${180 - murry.faceRedness * 80})` : '#FF69B4';
    ctx.fillStyle = shirtPink;
    ctx.beginPath();
    ctx.ellipse(x + 22, y + 22, 17 + bellySize, 15 + bellySize * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Collar
    ctx.fillStyle = '#FF1493';
    ctx.beginPath();
    ctx.moveTo(x + 16, y + 6);
    ctx.lineTo(x + 22, y + 14);
    ctx.lineTo(x + 28, y + 6);
    ctx.lineTo(x + 26, y + 4);
    ctx.lineTo(x + 22, y + 10);
    ctx.lineTo(x + 18, y + 4);
    ctx.closePath();
    ctx.fill();

    // Buttons
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(x + 22, y + 16, 2, 0, Math.PI * 2);
    ctx.arc(x + 22, y + 22, 2, 0, Math.PI * 2);
    ctx.fill();

    // Floral pattern (moves with belly)
    const flowers = [
        {dx: 10 - bellySize/4, dy: 18, c: '#FFFF00', size: 4},
        {dx: 32 + bellySize/4, dy: 16, c: '#00FF00', size: 3.5},
        {dx: 20, dy: 28 + bellySize/2, c: '#87CEEB', size: 4},
        {dx: 12, dy: 30 + bellySize/2, c: '#FFA500', size: 3},
        {dx: 30 + bellySize/4, dy: 26, c: '#FF6B6B', size: 3.5},
        {dx: 16, dy: 12, c: '#DDA0DD', size: 3},
    ];
    flowers.forEach(f => {
        // Flower petals
        ctx.fillStyle = f.c;
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            ctx.beginPath();
            ctx.ellipse(
                x + f.dx + Math.cos(angle) * f.size * 0.6,
                y + f.dy + Math.sin(angle) * f.size * 0.6,
                f.size * 0.5, f.size * 0.3, angle, 0, Math.PI * 2
            );
            ctx.fill();
        }
        // Flower center
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(x + f.dx, y + f.dy, f.size * 0.3, 0, Math.PI * 2);
        ctx.fill();
    });

    // === ARMS ===
    ctx.fillStyle = '#fdbf6f';
    // Left arm
    ctx.save();
    ctx.translate(x + 5, y + 14);
    ctx.rotate(-0.3 + armSwing);
    ctx.beginPath();
    ctx.ellipse(0, 8, 5, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    // Hand
    ctx.beginPath();
    ctx.arc(0, 18, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Right arm
    ctx.save();
    ctx.translate(x + 39, y + 14);
    ctx.rotate(0.3 - armSwing);
    ctx.beginPath();
    ctx.ellipse(0, 8, 5, 10, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 18, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // === HEAD ===
    // Neck
    ctx.fillStyle = '#fdbf6f';
    ctx.fillRect(x + 18, y + 2, 8, 6);

    // Head shape
    ctx.fillStyle = '#fdbf6f';
    ctx.beginPath();
    ctx.ellipse(x + 22, y - 6, 14, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ears
    ctx.beginPath();
    ctx.ellipse(x + 8, y - 6, 4, 6, -0.2, 0, Math.PI * 2);
    ctx.ellipse(x + 36, y - 6, 4, 6, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // Face redness when stressed
    if (murry.faceRedness > 0) {
        ctx.fillStyle = `rgba(255, 0, 0, ${murry.faceRedness * 0.3})`;
        ctx.beginPath();
        ctx.ellipse(x + 22, y - 6, 14, 12, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Hair
    ctx.fillStyle = '#5a3825';
    ctx.beginPath();
    ctx.ellipse(x + 22, y - 12, 13, 8, 0, Math.PI, 2 * Math.PI);
    ctx.fill();
    // Hair tuft
    ctx.beginPath();
    ctx.moveTo(x + 18, y - 18);
    ctx.quadraticCurveTo(x + 22, y - 24, x + 26, y - 18);
    ctx.quadraticCurveTo(x + 22, y - 20, x + 18, y - 18);
    ctx.fill();

    // Eyes
    const eyeSize = 4 * murry.eyeSize;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.ellipse(x + 16, y - 8, eyeSize, eyeSize * 0.8, 0, 0, Math.PI * 2);
    ctx.ellipse(x + 28, y - 8, eyeSize, eyeSize * 0.8, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pupils (look toward movement)
    const pupilOffset = murry.facing * 1.5;
    ctx.fillStyle = '#4a3728';
    if (!murry.isBlinking) {
        ctx.beginPath();
        ctx.arc(x + 16 + pupilOffset, y - 8, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.arc(x + 28 + pupilOffset, y - 8, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Eye shine
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(x + 15 + pupilOffset, y - 9, eyeSize * 0.2, 0, Math.PI * 2);
        ctx.arc(x + 27 + pupilOffset, y - 9, eyeSize * 0.2, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Closed eyes
        ctx.strokeStyle = '#4a3728';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + 12, y - 8);
        ctx.lineTo(x + 20, y - 8);
        ctx.moveTo(x + 24, y - 8);
        ctx.lineTo(x + 32, y - 8);
        ctx.stroke();
    }

    // Eyebrows
    ctx.strokeStyle = '#5a3825';
    ctx.lineWidth = 2;
    if (murry.belly > 80 || murry.state === 'pooping') {
        // Worried eyebrows
        ctx.beginPath();
        ctx.moveTo(x + 12, y - 14);
        ctx.lineTo(x + 20, y - 12);
        ctx.moveTo(x + 24, y - 12);
        ctx.lineTo(x + 32, y - 14);
        ctx.stroke();
    } else {
        // Normal eyebrows
        ctx.beginPath();
        ctx.moveTo(x + 12, y - 13);
        ctx.lineTo(x + 20, y - 13);
        ctx.moveTo(x + 24, y - 13);
        ctx.lineTo(x + 32, y - 13);
        ctx.stroke();
    }

    // Nose
    ctx.fillStyle = '#e8a862';
    ctx.beginPath();
    ctx.ellipse(x + 22, y - 4, 3, 2, 0, 0, Math.PI * 2);
    ctx.fill();

    // Mouth expression
    ctx.strokeStyle = '#8b5a3c';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';

    if (murry.mouthOpen > 0) {
        // Eating - open mouth
        ctx.fillStyle = '#8b5a3c';
        ctx.beginPath();
        ctx.ellipse(x + 22, y + 2, 5, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.ellipse(x + 22, y + 3, 3, 2, 0, 0, Math.PI);
        ctx.fill();
    } else if (murry.state === 'pooping') {
        // Straining face
        ctx.beginPath();
        ctx.ellipse(x + 22, y + 2, 4, 3, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Gritted teeth
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x + 19, y + 1, 6, 3);
        ctx.strokeStyle = '#8b5a3c';
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            ctx.moveTo(x + 20 + i * 2, y + 1);
            ctx.lineTo(x + 20 + i * 2, y + 4);
        }
        ctx.stroke();
    } else if (murry.state === 'dancing') {
        // Big happy smile
        ctx.beginPath();
        ctx.arc(x + 22, y, 6, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.stroke();
        // Rosy cheeks
        ctx.fillStyle = 'rgba(255, 150, 150, 0.5)';
        ctx.beginPath();
        ctx.ellipse(x + 12, y - 2, 4, 3, 0, 0, Math.PI * 2);
        ctx.ellipse(x + 32, y - 2, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();
    } else if (murry.belly > 80) {
        // Uncomfortable grimace
        ctx.beginPath();
        ctx.moveTo(x + 17, y + 2);
        ctx.lineTo(x + 20, y + 4);
        ctx.lineTo(x + 24, y + 2);
        ctx.lineTo(x + 27, y + 4);
        ctx.stroke();
    } else if (murry.hunger < 30) {
        // Hungry frown
        ctx.beginPath();
        ctx.arc(x + 22, y + 6, 5, 1.2 * Math.PI, 1.8 * Math.PI);
        ctx.stroke();
    } else {
        // Normal slight smile
        ctx.beginPath();
        ctx.arc(x + 22, y, 4, 0.15 * Math.PI, 0.85 * Math.PI);
        ctx.stroke();
    }

    // Sweat drops
    ctx.fillStyle = '#87CEEB';
    murry.sweatDrops.forEach(drop => {
        ctx.beginPath();
        ctx.moveTo(drop.x, drop.y);
        ctx.quadraticCurveTo(drop.x - 3, drop.y + 5, drop.x, drop.y + 8);
        ctx.quadraticCurveTo(drop.x + 3, drop.y + 5, drop.x, drop.y);
        ctx.fill();
    });

    // Status indicators above head
    if (murry.belly > 70) {
        const urgency = murry.belly > 90 ? 'üöΩ‚ùó‚ùó' : murry.belly > 80 ? 'üöΩ‚ùó' : 'üöΩ';
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = murry.belly > 90 ? '#ff0000' : '#ff8800';
        ctx.textAlign = 'center';
        ctx.fillText(urgency, x + 22, y - 28);
    }

    // Power-up indicators
    if (murry.tumsActive > 0) {
        ctx.font = '12px Arial';
        ctx.fillText('üíä', x + 8, y - 26);
    }
    if (murry.laxativeActive > 0) {
        ctx.font = '12px Arial';
        ctx.fillText('üí©', x + 36, y - 26);
    }

    ctx.restore();
}

function drawStinkClouds() {
    stinkClouds.forEach(cloud => {
        ctx.save();
        ctx.globalAlpha = cloud.life * 0.6;
        ctx.translate(cloud.x, cloud.y);
        ctx.rotate(cloud.rotation);

        // Green stink cloud
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, cloud.size);
        gradient.addColorStop(0, 'rgba(100, 150, 50, 0.8)');
        gradient.addColorStop(0.5, 'rgba(80, 120, 40, 0.4)');
        gradient.addColorStop(1, 'rgba(60, 100, 30, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        // Wavy cloud shape
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const wobble = Math.sin(i * 2 + cloud.rotation * 5) * cloud.size * 0.2;
            const r = cloud.size + wobble;
            if (i === 0) {
                ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
            } else {
                ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
        }
        ctx.closePath();
        ctx.fill();

        // Stink lines
        ctx.strokeStyle = `rgba(80, 120, 40, ${cloud.life * 0.5})`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            const startAngle = cloud.rotation + i * 2;
            ctx.moveTo(Math.cos(startAngle) * 5, Math.sin(startAngle) * 5);
            ctx.quadraticCurveTo(
                Math.cos(startAngle + 0.5) * cloud.size * 0.5,
                Math.sin(startAngle + 0.5) * cloud.size * 0.5 - 5,
                Math.cos(startAngle + 1) * cloud.size * 0.7,
                Math.sin(startAngle + 1) * cloud.size * 0.7 - 10
            );
            ctx.stroke();
        }

        ctx.restore();
    });
}

function drawParticles() {
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
}

function drawFloatingTexts() {
    floatingTexts.forEach(t => {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = `bold ${t.size}px Arial`;
        ctx.textAlign = 'center';

        // Text shadow
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillText(t.text, t.x + 2, t.y + 2);

        ctx.fillStyle = t.color;
        ctx.fillText(t.text, t.x, t.y);
    });
    ctx.globalAlpha = 1;
}

function draw() {
    ctx.save();
    ctx.translate(screenShake.x, screenShake.y);

    drawBackground();
    drawPlatforms();
    drawToilet();
    powerups.forEach(p => drawPowerup(p));
    sandwiches.forEach(s => drawSandwich(s));
    drawStinkClouds();
    drawMurry();
    drawParticles();
    drawFloatingTexts();

    ctx.restore();
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// Initialize
setupMobileControls();
showOverlay('üçó MURRY FUEL üçó',
    'Help Murry devour chicken sandwiches!',
    'Eat until FULL ‚Üí Find the TOILET before it\'s too late! ‚Üí REPEAT!\n\n‚ö†Ô∏è Wait too long = ACCIDENT! (-200 pts)',
    'START GAME');
gameLoop();
</script>
</body>
</html>
